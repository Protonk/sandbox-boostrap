# macOS Sandbox Concept Atlas

## Overview

Apple’s macOS “Seatbelt” sandbox is a security mechanism that confines processes to limited operations via sandbox profiles. This concept atlas distills the core principles and terminology of Seatbelt as documented in the provided repository files, and maps how each concept is used across those documents. We first enumerate the key sandbox concepts (as defined in the glossary and related files), then show where each concept appears – whether it’s introduced, utilized, or refined in different files. We identify invariants that remain consistent throughout the documentation, as well as any overlapping definitions or points of friction/ambiguity between files. We also highlight version-specific caveats (notably for macOS 14.x) where real-world behavior diverges from the idealized model. Finally, we propose a set of documentation edits to address gaps, unify terminology, and incorporate version-related nuances. This atlas is based strictly on the local documentation files – Orientation.md, Concepts.md, Appendix.md, ERRATA.md, Canon.md, etc. – without introducing outside information. All citations refer to these files. The aim is to provide a consolidated reference that keeps the Seatbelt sandbox model clear and consistent, even as the system evolves.

## Concept-by-Concept Atlas

Below is an inventory of core concepts in Apple’s sandbox (Seatbelt) system. Each concept is defined or summarized in terms of the documentation’s language, and followed by notes on where it appears across the files (where it’s defined, used, or qualified). Concepts are primarily drawn from Concepts.md, with additional concepts from the Appendix noted as candidates for inclusion in the main glossary.

### SBPL Profile

Definition: An SBPL profile is the high-level sandbox policy written in Apple’s Scheme-like Sandbox Profile Language (SBPL). It declares a version, a default rule (almost always default-deny), and a list of specific allow/deny rules that name operations and apply filters. In other words, the SBPL profile is the human-readable “source code” of a sandbox policy which gets compiled by libsandbox into a binary form. For example, a simple SBPL profile might specify (deny default) and then whitelist certain operations (file reads, network access, etc.) with filters on paths or other parameters.
Concepts.md: Defines SBPL profile as the DSL form of a sandbox policy, highlighting that it’s the form where rules like file-read* and filters like subpath are expressed for humans.
Orientation.md: Introduces SBPL as Stage 1 of the policy lifecycle – the Scheme-like source that is compiled into the kernel policy. Orientation emphasizes that most profiles start with a default deny rule and then specific allows/denies for each operation. It also notes that SBPL uses S-expression syntax for rules and that one should treat SBPL as the high-level form that the sandbox tool aims to reproduce.
Appendix.md: Provides a “Sandbox DSL Cheatsheet” with examples of SBPL syntax and rules. It shows the typical structure of an SBPL file (version declaration, default deny, operation rules with optional modifiers and filters). The Appendix reinforces patterns like default-deny-by-default and gives concrete SBPL examples for file system, networking, etc.
ERRATA.md: There is no direct contradiction of the SBPL syntax itself in errata. (However, Errata does note that many system-provided profiles include parameterized sections not explicitly covered in the main docs – see Parameterization below.)

### Operation

Definition: An operation is a named class of kernel action that the sandbox can mediate (control). Examples include file operations (file-read*, file-write*), network access (network-outbound), inter-process communication (mach-lookup), system calls (sysctl-read), and so on. In an SBPL rule, the operation is the verb being allowed or denied. In the compiled binary profile, each operation is assigned a numeric operation ID and has an entry point into the policy’s decision graph. Conceptually, an operation asks “What kind of sensitive action is the process trying to do?” and then the sandbox policy decides if it’s permitted.
Concepts.md: Provides the formal definition of Operation, listing examples and noting that in SBPL it’s a symbol in rules, while in the binary profile it’s an integer key into a table of rule entry points.
Orientation.md: Highlights Operation as one of the foundational terms. It describes an operation as a named action like file-read* or mach-lookup, with each operation having a numeric ID and a pointer into the compiled rule graph. Orientation uses operations extensively in examples (e.g., it talks about an operation’s rule graph, how the kernel identifies the operation ID of a syscall, etc.).
Appendix.md: The Appendix’s cheat sheet and reference sections enumerate many operations and their families. It notes that at the SBPL level, operations are just symbolic names for classes of actions (with the actual numeric mapping defined in libsandbox and the compiled profile). It provides lists of operations by category (filesystem, networking, IPC, etc.) to illustrate the vocabulary.
ERRATA.md: One erratum (“Public headers and symbols”) notes a practical issue with operations on macOS 14.x: the traditional method of extracting operation names (from the Sandbox.kext binary or libsandbox.dylib symbols) no longer works because the kext isn’t easily accessible. This doesn’t change the concept of operations, but it affects how tools discover the full list of operation identifiers (see Operation Vocabulary Map below).

### Filter

Definition: A filter is a predicate (condition) applied to an operation’s parameters or to the process state, used to decide whether a rule matches. Each filter in SBPL is expressed as a key–value check, for example a path filter or entitlement check. In the SBPL source, filters appear as clauses after the operation name (e.g. (allow file-read* (literal "/path"))). In the compiled profile, each filter is represented as a node that tests a specific key and value and branches based on whether the condition is met. Filters include things like path checks (literal, subpath, regex for matching file system paths), vnode properties (vnode-type like REGULAR-FILE vs. DIR), Mach service names (global-name), network addresses (remote ip), entitlement presence (entitlement-is-present "X"), codesigning flags (csr for SIP status), etc.. Essentially, filters narrow the scope of a rule to specific resources or conditions.
Concepts.md: Defines Filter as a key–value predicate on an operation’s arguments or on system/process metadata. It lists examples of filter keys (path predicates, vnode-type, Mach names, network addresses, entitlements, signing identifier, “csr” for SIP status, etc.), making clear that in SBPL these are s-expressions attached to rules, and in the compiled graph they correspond to test nodes.
Orientation.md: Introduces Filter as another core term, describing it as a predicate on the operation’s arguments or state (paths, vnode type, Mach service name, socket address, entitlements, etc.). Orientation emphasizes that filters are how rules get conditional – and notes that the Appendix should be consulted for details on filter syntax and categories.
Appendix.md: The Appendix devotes a large section to filters. It explains the general concept (“a filter narrows the applicability of a rule” in SBPL) and shows many specific filter examples by category: path-based filters (path, literal, subpath, regex), network filters (remote ip, remote tcp), other filters like sysctl-name for syscalls, extension for sandbox extension tokens, process attributes (signing-identifier, entitlement-is-present, csr, etc.). The Appendix also notes that in the binary, filters are encoded as small integer key and value indices into shared tables.
ERRATA.md: No direct contradictions for the concept of filters. (However, one erratum about AppleMatch touches on regex filter implementation – see Regex Table and AppleMatch under Frictions.)

### Metafilter

Definition: A metafilter is a logical combination of other filters, allowing boolean logic within a rule. In SBPL, these appear as special combinators: require-all (logical AND of a set of filters), require-any (logical OR), and require-not (logical NOT). Metafilters let policy authors express compound conditions like “this rule applies only if all of these filters match” or “allow if any of these sub-filters match” etc. For example, one could write a rule that allows file access if a path matches a regex and the file is not a symlink (using require-all with a regex filter and a (require-not (vnode-type SYMLINK)) filter). In the compiled graph, these combinators don’t exist as named entities – they are compiled away into the structure of the decision graph (multiple filter nodes and edges representing the logic).
Concepts.md: Defines Metafilter as the AND/OR/NOT combinators (require-all, require-any, require-not) that glue filters together in SBPL. It explains that they allow complex conditions like “X and (Y or Z)” to be expressed cleanly, and that in the binary representation these are realized as specific graph patterns rather than explicit nodes labeled “AND/OR”.
Orientation.md: Mentions metafilters under core terms (calling it “Metafilter / condition structure”). It notes the same three SBPL forms and that in the binary format the structure is encoded in the graph shape, not as explicit tags. Orientation’s Stage 1 example shows require-all and require-not in use, and it emphasizes one must understand how these turn into decision graphs (with details in Appendix).
Appendix.md: Demonstrates how to use require-any, require-all, and require-not in SBPL with examples and the intended semantics (allow if any match, allow if all match, etc.). It also discusses nesting metafilters to express complex conditions. The Appendix’s binary format section implicitly covers how these appear in compiled form (since a chain of filter nodes linked together represents the same logic).
ERRATA.md: No specific errata for metafilter logic – the concept remains the same on modern systems (the logic of combining conditions hasn’t changed).

### Decision

Definition: A decision in the sandbox context is the terminal outcome of evaluating the policy for a given operation and its arguments. In SBPL source, decisions are implicit in the rule form: an (allow ...) rule indicates an “allow” decision if the filters match, and a (deny ...) rule indicates a “deny” decision. In the compiled profile, decisions are explicit terminal nodes (or result codes) in the policy graph that specify whether to allow or deny, and possibly include flags for additional actions (logging, user prompts). The typical decisions are “allow” (let the operation proceed) or “deny” (block it, often causing an EPERM error). The sandbox’s enforcement at runtime is essentially finding the applicable decision for the operation – if any layer returns a deny decision, the operation is blocked.
Concepts.md: Defines Decision as the terminal outcome (usually allow or deny) plus optional flags like “log” or “ask for consent”. It notes that in SBPL you don’t write “allow” vs “deny” as separate objects – it’s part of the rule – but in the compiled form, decisions appear as terminal nodes or codes that end the graph traversal. The definition makes clear that whatever decision node the kernel lands on will determine whether the system call is allowed or not.
Orientation.md: Lists Decision as one of the four key terms, describing it as a verdict (allow/deny) with optional modifiers (report, user-consent) and implemented as terminal nodes in the compiled graph. Orientation also explains the runtime evaluation process: the kernel walks the pre-compiled decision structure and the decision node reached will allow or block the syscall. In the Policy Lifecycle (Stage 4), it elaborates that if platform and app-specific policies both allow, the call proceeds; if any denies, it’s blocked.
Appendix.md: The SBPL cheatsheet portion implies decisions via the (allow ...) vs (deny ...) forms, and the binary format sections describe result codes or terminal node opcodes (e.g., 0x00 = allow, 0x01 = deny in the older format). The Appendix also covers Action Modifiers (next concept) which are closely tied to decisions. In summary, the concept of an “allow or deny decision node” is present throughout Appendix descriptions of the graph.
ERRATA.md: No direct changes to the concept of “decision” – although some errata entries discuss how certain decisions (like user consent gating) appear in newer profiles, the fundamental allow/deny logic remains as documented.

### Action Modifier

Definition: An action modifier is an annotation on a rule that alters the side-effects of a decision without changing the basic allow/deny outcome. In SBPL, action modifiers are expressed by wrapping the rule with an extra form like (with report) or user-consent wrappers. For example, (allow (with report) sysctl ...) means “allow this operation, and log (report) the access”. Other modifiers tie into macOS’s Transparency/Consent system (TCC), e.g. requiring user approval for camera or microphone access (these appear as special SBPL modifiers that defer the decision pending user consent). In the compiled profile, action modifiers correspond to extra flags on decision nodes (for logging, reporting, user-interaction, etc.).
Concepts.md: Defines Action Modifier as a rule annotation like (with report) or user consent modifiers, which add behaviors such as logging or prompting the user. It clarifies that these don’t change “allow vs deny” but add side effects to the decision (log this event, ask the user, etc.), and that in the binary these are encoded as flags or fields on the terminal decision nodes.
Orientation.md: Does not list action modifiers as a separate bullet in the “four terms” (they are mentioned as part of the Decision description and examples). However, Orientation’s SBPL examples do show an (allow (with report) ...) usage, and it notes in passing that decisions can have flags like report or user consent.
Appendix.md: Has a dedicated section on Action Modifiers with examples. It explains modifiers like (with report) and outlines newer “user-consent” modifiers (for TCC) in Section 6.2. The Appendix indicates these modifiers are part of SBPL syntax and that their semantics are to log or to defer to user approval workflows for sensitive resources.
ERRATA.md: No specific entry on action modifiers, but one point in Errata (“AppleMatch access”) is tangential: it notes needing userland regex parsing since the system library isn’t available – not directly about modifiers. The concept and usage of (with report) or consent modifiers remain the same; newer macOS versions simply have more of these user-consent hooks, which the documents already acknowledge in Appendix.

### Profile Layer

Definition: A profile layer refers to the distinct sandbox policy levels that can apply to a process. In macOS’s model, there is a global platform policy (the built-in sandbox rules that apply to nearly all processes) and an optional per-process policy (for apps that are in the App Sandbox or for processes that explicitly call sandbox initialization functions). These layers stack: when a process is sandboxed, the platform policy is evaluated first, and then the app’s own sandbox profile is evaluated (if one is present). Thinking in terms of layers helps clarify where a given rule comes from – e.g., if a file operation is denied, was it denied by the global policy or the app policy? The concept of profile layers ensures we don’t attribute all sandbox decisions to a single monolithic profile when multiple layers are in effect.
Concepts.md: Defines Profile Layer explicitly as the notion of which sandbox policy layer is being applied: global platform versus per-process (App Sandbox or custom). It notes that multiple layers can apply to one operation and that typically the platform policy runs first, then the per-process policy, which matches the actual enforcement order. The definition emphasizes using “layers” to keep straight where a particular rule lives and why a decision was made at a certain layer.
Orientation.md: Describes the core Seatbelt model as having potentially two sandbox policies for each process: a global platform policy (applied to almost everything) and an optional per-process policy if the process is App Sandbox-enabled or calls sandbox_init to apply a custom profile. It also mentions that these policies are stored as labels in the process credentials. In the runtime evaluation (Stage 4), Orientation explicitly outlines that the platform policy is evaluated first, and only if it allows the operation does the per-process layer get consulted.
Appendix.md: There is a section in Appendix (Policy stacking and platform sandbox) that addresses how sandbox policies stack in enforcement. It reiterates that the platform policy is applied first and can short-circuit the decision (a platform “deny” stops everything) and that the effective outcome is essentially the combination (logical AND) of platform and process-specific policies. While the term “profile layer” might not be used verbatim, the concept is fully described in the stacking context.
ERRATA.md: No direct errata on the existence of layers – the layer concept holds true. (One could argue the deprecation of sandbox-exec in macOS 14 means users can no longer easily add a custom per-process layer at runtime, but the layering model itself (platform vs app) hasn’t changed.)

### Sandbox Extension

Definition: A sandbox extension is a token-based capability that extends the sandbox’s permissions for a process in a controlled way. Instead of permanently coding a rule into a profile, an extension is a dynamically issued string (by a trusted system component) that a process can “consume” to gain additional access – for example, access to a specific file or directory, Mach service, or other resource – beyond what its static profile allows. The sandbox policy recognizes these tokens via special filters (the extension filter key in SBPL rules), and if a process presents a valid extension token, the rule will allow access to the associated resource. Extensions are used by macOS subsystems (like TCC or LaunchServices) to grant temporary exceptions – bridging the gap between static sandbox profiles and dynamic, per-request decisions.
Concepts.md: Defines Sandbox Extension as a token-based capability that widens what a sandbox allows, for specific resources, when the token is present. It emphasizes that extensions enable dynamic exceptions without altering the SBPL profile itself – trusted components hand out opaque strings and the sandbox policy has rules like (extension "com.apple.app-sandbox.read") to allow access if the token matches. This concept positions extensions as a crucial mechanism for things like giving a sandboxed app access to a file the user selected (the system issues an extension token for that file).
Orientation.md: Does not delve deeply into extensions, but it does list “extensions” among the categories of filters (e.g., extension filters are mentioned alongside entitlements and SIP state in describing filters). It also alludes to them in the context of multi-layer policies – for instance, Orientation notes that extensions are part of the state considered (Stage 4 uses “extensions” as one of the things Seatbelt can check in operation arguments or process state).
Appendix.md: The Appendix’s filter examples include sandbox extensions. For example, it shows filters like (extension "com.apple.app-sandbox.read") and (extension "com.apple.sandbox.container") as representative filters one might see. The presence of these in the cheatsheet highlights that the SBPL language includes an extension filter key to gate rules on having a particular extension token. The Appendix likely also covers how extensions interplay with policy stacking in the sense that extensions are dynamic and apply across those layers.
ERRATA.md: No specific errata about extensions. They behave as described; however, one erratum (“Storage locations”) notes that on macOS 14.x, sandbox profiles (which likely include rules about extensions) are now accessible in the file system rather than kernel caches – but that’s about where profiles live, not about extensions themselves.

### Policy Lifecycle Stage

Definition: The policy lifecycle of a sandbox profile has four conceptual stages from authoring to enforcement:
SBPL Source (Stage 1) – The human-written Scheme-like policy text.
Compilation (Stage 2) – libsandbox.dylib (using a TinyScheme engine) parses the SBPL, expands macros, assigns numeric IDs to operations and filter keys, and compiles the rules into a binary profile (a serialized decision graph plus tables).
Kernel Install (Stage 3) – The compiled profile blob is loaded into the kernel (via special syscalls) and attached to the process’s credential as a MAC policy label. For app sandbox, this happens at process launch (inheriting from the parent or via sandbox_init), and for the platform profile it’s essentially done for all processes.
Runtime Enforcement (Stage 4) – When a sandboxed process makes a system call, the kernel (Sandbox.kext) looks up the relevant operation’s graph in the profile, walks through filter nodes based on the call’s arguments, and arrives at a decision (allow/deny). If there are multiple profiles (layers), it evaluates them in order (platform then process) and combines the results.
These stages help to separate how a policy is written vs how it’s stored vs how it’s applied at runtime.
Concepts.md: Defines Policy Lifecycle Stage as the distinct forms a sandbox policy takes: (1) SBPL text, (2) the libsandbox/TinyScheme intermediate (often seen as a list of per-operation rules in userland memory), (3) the compiled binary blob (with header, node array, tables), and (4) in-kernel evaluation via MAC hooks. This entry emphasizes understanding which stage you’re dealing with when debugging or extending the system.
Orientation.md: Section 3. Policy Lifecycle: From SBPL to Kernel Decisions directly corresponds to these four stages. Orientation explicitly walks through Stage 1 SBPL, Stage 2 compilation details, Stage 3 kernel installation (mentioning the syscall and label storage), and Stage 4 runtime evaluation. It provides context on what XNUSandbox (the user-space tool) mainly deals with (Stage 3 artifacts, reconstructing Stage 1 output from them).
Appendix.md: The Appendix covers Stage 2 and Stage 3 in detail under the binary formats section (how SBPL is serialized, what the binary contains, how it’s stored in iOS/macOS images). It also hints at Stage 4 under policy stacking (how the kernel uses the profiles). The Appendix doesn’t enumerate “Stage 1/2/3/4” explicitly, but its structure mirrors those steps (with sections on SBPL syntax, on compiled binary graphs, on how policies stack at runtime, etc.).
ERRATA.md: The errata file captures where real macOS 14.x behavior diverges in Stage 3 and Stage 4:
E.g., Stage 3 divergence: sandbox_apply (the userland call to install a profile) is present but effectively blocked by SIP without entitlement, meaning an unprivileged process can’t actually add a new sandbox layer at runtime. Orientation didn’t mention this restriction (it describes Stage 3 in general terms), so Errata flags it.
Stage 4 divergence: the sandbox-exec tool (which was a way to launch a process in a sandbox from the command line) is now non-functional on macOS 14, returning EPERM – again reflecting Apple locking down sandbox usage in recent versions.

### Binary Profile Header

Definition: The binary profile header is a fixed-format header at the start of a compiled sandbox profile blob. It contains metadata about the compiled profile, such as a magic number or version to identify the format, and crucial offsets and counts for the various sections of the profile. Specifically, the header typically records how many operations, how many nodes, how many regexes/literals are present, and where in the blob to find the operation table, the node array, the regex table, etc.. In bundled multi-profile blobs, the header also includes info about how many profiles are bundled and pointers to each sub-profile’s data. Essentially, reading the header is the first step for any sandbox profile decoder, as it tells the decoder where everything is in the binary.
Concepts.md: Defines Binary Profile Header as the fixed-layout structure at the start of a compiled profile blob with format/version info and offsets/counts for all major sections (op table, node array, regex table, literal table, etc.). It highlights that the header is the “entry point” for decoding: it tells you how many operations exist and where each section of data begins.
Orientation.md: In the “Mapping code to concepts” section, Orientation instructs one to look for structs corresponding to profile headers, listing the typical fields: magic/format ID, version, counts of operations/nodes/regexes, and offsets to the operation pointer table, node array, regex pointers, literal/regex blob, etc.. This matches exactly what the Binary Profile Header concept describes. Orientation assumes the reader will parse these fields to navigate the profile.
Appendix.md: The Appendix’s section on Binary Profile Formats describes headers for different versions. For the “early decision-tree format”, it lists the header fields like re_table_offset, re_table_count, and the op_table offset array. For the later graph format, it describes a header with magic, counts, offsets for each section, and in the bundled case, a bundle header with number of profiles and an index of profiles. All these details reinforce the concept of the header as containing structured offsets.
ERRATA.md: One erratum (“Format detection and re_table_offset”) notes that on modern macOS 14, profiles compiled via sandbox_compile report a re_table_offset = 0 in the header, which confused legacy parsers. This suggests Apple may have introduced a new variant or quirk in the header format. The errata implies that tools need to handle a possibly different header layout or at least the scenario where the regex table offset is zero (meaning perhaps no regex section or a new encoding). This is a version-specific detail that doesn’t change the existence of a header, but indicates the header format can evolve (see Profile Format Variant below).

### Operation Pointer Table

Definition: The operation pointer table is an array in the compiled profile that maps each operation ID to the starting point of that operation’s rule graph in the node array. In other words, it’s an index: the Nth entry in this table gives the offset (or index) of the first node for the operation with ID N. This allows the sandbox to quickly jump to the relevant part of the decision graph when a particular operation needs to be evaluated. If an operation has no rules, its pointer might refer to a default decision (or be null/invalid indicating default action). Without this table, the compiled nodes would be an undifferentiated heap and you wouldn’t know where one operation’s policy ends and the next begins.
Concepts.md: Defines Operation Pointer Table as an array indexed by operation ID, where each entry is an offset into the node array for that operation’s graph. It explains that instead of separate contiguous blocks per operation, a single node array is often used and this table serves as the set of entrypoints. The definition stresses the importance of this table for decoding: you use it to start traversing nodes for a given operation.
Orientation.md: Mentions this concept in a couple of ways. In the architecture overview, Orientation notes that in compiled form each operation has an entrypoint into a rule graph via an ID. Later, in mapping code, it explicitly says to find arrays mapping op IDs to entrypoints, giving examples: in early formats op_table[op_id] with offsets, in later formats an “Operation Node Pointers” array. So Orientation recognizes the pointer table under possibly different names (it references the Appendix’s terminology “Operation Node Pointers”).
Appendix.md: Describes this structure, though it calls it slightly differently. In the iOS 7–9 graph-based format description, the Appendix lists “Operation Node Pointers” which is an array indexed by operation ID where each entry is an offset into the node section. This is effectively the same as the Operation Pointer Table (just a naming difference: adding “Node” in the name). The early format description calls it op_table (with 16-bit offsets). So the Appendix thoroughly covers how each format implements this operation index.
ERRATA.md: The concept is consistent, but one erratum (“Public headers and symbols”) indirectly relates: it notes that in macOS 14, one can’t easily extract the operation names from the kext, which is a step towards building the operation table mapping (not the table in the profile, but the mapping in tools). The actual operation pointer table within the profile still exists and needs to be parsed; no errata indicate it changed, apart from the format nuance with regex offset (which doesn’t directly affect the op table).

### Policy Node

Definition: A policy node is an element of the compiled sandbox policy graph. Each node is either a non-terminal filter node or a terminal decision node. A filter node represents a test of one filter condition: it contains a filter key (like “path prefix matches X” or “entitlement Y present”) and a reference to some value (like a string index or an enum), and it has two outgoing edges – one for the case where the filter matches and one for when it doesn’t match. A decision node contains an allow/deny outcome (and possibly flags for logging/consent) and marks the end of that path in the graph. By linking many nodes together (with filter nodes leading to other filters or to decisions), the sandbox forms a decision tree/graph for each operation.
Concepts.md: Defines Policy Node in exactly these terms: it’s either a filter test node with “match” and “unmatch” successors, or a terminal decision node with an outcome and optional flags. The concept entry notes that all the rules are built from these nodes, and operations pick a starting node via the op-pointer table, then traverse through filter nodes until a terminal node is reached.
Orientation.md: While Orientation doesn’t use the exact term “policy node” in its core definitions, it repeatedly talks about “nodes” when describing the compiled structures. For instance, it says a compiled profile is a graph or tree of nodes representing filter tests and decisions. Orientation’s explanation of runtime evaluation is essentially “walk the operation’s rule graph following filter tests until reaching a terminal decision” – which is describing traversing policy nodes. It also discusses node structures in the context of code (e.g., instructing to identify the node struct in the C code, with fields for filter type, arguments, and offsets).
Appendix.md: The Appendix is full of information about nodes. The early format section defines a “handler record” which includes an opcode byte for terminal vs non-terminal, with filter nodes containing a filter type and argument and pointers for match/unmatch, and terminal nodes containing a result code. In the later format sections, it describes each “Operation Node Action” as essentially a node with some number of filters and possibly a decision. The Appendix even mentions that SandBlaster (an external reversing tool) calls these serialized rule elements “operation nodes” – effectively the same concept by a different name.
ERRATA.md: No errata specifically on how nodes work. The fundamental concept of filter and decision nodes remains unchanged. (If anything, the errata about regex might imply something about certain node fields for regex filters, but that doesn’t alter the concept of a node.)

### Policy Graph (PolicyGraph)

Definition: A policy graph is the directed graph composed of all the policy nodes (filters and decisions) for a given sandbox profile. It’s “graph” in the sense that filter nodes branch to other nodes, forming potentially complex structures (not strictly a tree if there are shared subgraphs). Each operation’s rules form a subgraph, and together they constitute the full policy graph. In many contexts, the policy graph is the internal representation used by tools to analyze or pretty-print the sandbox – once you decode the binary blob into a PolicyGraph data structure, you can do things like reconstruct SBPL, visualize it, or compare profiles structurally.
Concepts.md: Defines Policy Graph (often referenced as a PolicyGraph type) as the full per-profile representation connecting operations, filters, metafilters, and decisions. It highlights that for each operation ID, there’s an entrypoint into this directed graph of nodes. The concept entry notes that once you have a PolicyGraph, you can render it back to SBPL, run analyses, etc., indicating it’s the canonical intermediate form for understanding a sandbox profile.
Orientation.md: Describes the sandbox policy in terms of a graph: e.g., “compiled profile is a graph or decision tree of nodes”. It also uses the term “rule graph” when talking about each operation’s set of rules. In various places, Orientation contrasts earlier decision-tree format vs later graph-based formats, implying the current model is a graph of nodes (which can handle things like shared substructures for require-any/all). The concept of the graph is inherent in Orientation’s explanation of how the kernel walks it for enforcement and how XNUSandbox reconstructs it for output.
Appendix.md: The Appendix goes into depth on policy graphs. It explains at a high level that the compiled profiles encode the policy as a graph of nodes. It then provides details on how the graph is stored: in later formats, there’s a single Operation Node Actions section containing all nodes which collectively form the graph, with the operation pointer table pointing into it. It also discusses that require-all/any/not metafilters are compiled into specific node patterns, meaning the graph structure encodes those logic combinations. The Appendix (especially section 5 of the Binary Formats part) explicitly calls out how each operation’s policy is a subgraph of the nodes, and how default decisions are represented, etc.
ERRATA.md: No direct mention of “policy graph” changes. The existence and concept of the graph is stable. (The “Format detection” erratum implies a new layout but still a graph structure exists; nothing suggests Apple moved away from the graph model.)

### Regex / Literal Table

Definition: The regex/literal table is a shared data section in the compiled profile that holds all the literal strings and compiled regular expressions used by the profile’s filters. Instead of storing file path strings or regex patterns directly in each filter node, the compiler puts all unique strings and regex bytecodes into a table and then just references them by index from the filter nodes. This makes the profile more compact and allows reuse of the same string in multiple rules. There are typically two related structures: a literal table (for literal strings/bytes) and a regex table (for regex bytecode or NFA fragments), or sometimes a combined section. In SBPL, filters like (literal "/bin/ls") or (regex #"^/Users/.*") correspond to entries in these tables in the binary.
Concepts.md: Defines Regex/Literal Table as the shared pool of string data and serialized regex NFAs referenced by filter nodes. It explains that compiled profiles store paths/patterns once in this combined section, and filter nodes just carry small indices into the table. Decoding these tables is necessary to reconstruct concrete SBPL filter expressions from the numeric indices.
Orientation.md: Mentions these tables in a couple of ways. In Stage 2 (compilation), Orientation notes that regexes are compiled into AppleMatch NFAs and stored in a separate table. In the code-mapping guidance (Orientation section 5.1 and 5.5), it explicitly says to look for the regex pointer table and the literal/regex blob in the data structures. It describes that filter arguments may be indices into these tables, and one must map those back to strings or patterns.
Appendix.md: Provides details about these tables. For the later formats, it defines “Regular Expression Pointers” (an array of offsets into the regex/literal section) and “Literals and Regular Expressions” (the section containing actual regex bytecode and literal strings). For the older format, it describes re_table_offset and re_table_count in the header to locate regex-related data, which AppleMatch.kext uses. The SBPL cheatsheet in Appendix also implicitly references these by showing how filters like (regex #"pattern") appear at source, noting that under the hood those correspond to entries in a regex table.
ERRATA.md: One erratum (“AppleMatch access”) is relevant: it notes that in macOS 14.x, the userland library libMatch (which was used by older tools to interpret regex bytecodes from the regex table) is not readily available. This means that although the regex table still exists in the profile, one cannot rely on Apple’s library to decode the regex patterns – the project had to implement its own regex parser (e.g., using a Python module). This is a drift in tooling rather than the structure itself. Another erratum (“Format detection and re_table_offset”) suggests that in profiles compiled on modern macOS, the re_table_offset might be zero or handled differently, implying a potential format change in how the literal/regex data is stored (possibly integrated or not used in the same way for certain profiles).

### Profile Format Variant

Definition: A profile format variant refers to the specific binary format in which a sandbox policy is encoded. Over time, Apple has changed the internal representation of sandbox profiles, so “variants” include: an older decision-tree format (seen in early macOS/iOS) where each node was a small record with an opcode, and newer graph-based formats where there are separate sections (header, node array, tables, etc.) and possibly support for bundling multiple profiles in one blob. For example, Dionysus Blazakis (2011) documented an early format (flat list of handlers), and the SandBlaster (2016) research described a later format with explicit node graphs and tables. Each variant uses the same conceptual building blocks (operations, filters, decisions) but organizes them differently in bytes. Recognizing the variant is important for a tool like XNUSandbox to parse the blob correctly.
Concepts.md: Defines Profile Format Variant as a concrete on-disk/in-kernel encoding of compiled policies, such as the early decision-tree vs later graph-based formats, including the bundled multi-profile format used in newer systems. It notes that all variants share the core concepts (ops, filters, nodes, graphs) but differ in headers, node layout, section arrangement – meaning a decoder must handle each explicitly.
Orientation.md: Mentions the existence of different formats in a few places. Early on, it says “keep track of which era… older decision-tree formats vs later graph-based formats”. Orientation’s references to Blazakis-era vs modern also imply format differences. The Errata.md is pointed out when orientation’s invariant says if something contradicts the model, treat it as drift (which could include new format quirks).
Appendix.md: The Appendix essentially has a mini history of format variants in its “Binary Profile Formats and Policy Graphs” part. It describes the Early Decision-Tree Format in detail (likely corresponding to macOS 10.5–10.6 era), then the iOS 7–9 Graph-Based Formats (which apply similarly to macOS since the codebase unified), and notes the bundled profile format introduced later (multiple profiles in one blob, used by iOS 9+ and macOS for platform profile bundling). These sections give concrete differences between variants (different header fields, presence of bundle info, different node encoding).
ERRATA.md: An important entry here: “Format detection and re_table_offset”. It notes that profiles compiled on macOS 14.x had re_table_offset = 0 which the legacy parser didn’t expect (treated as unsupported). This suggests a new variant or a slight change in format not covered in the current docs. In other words, Apple may have introduced another variant or change (perhaps eliminating a separate regex table in favor of something else). The erratum explicitly says graph-based support is needed – implying our model (which includes graph formats) is still correct, but the implementation details changed. This is precisely the kind of “drift to be documented” as a new variant. It underscores the need to update the documentation to handle this modern variant in addition to those already described.

### Operation Vocabulary Map

Definition: The Operation Vocabulary Map is the bidirectional mapping between the numeric operation IDs (used internally in compiled profiles) and the human-readable operation names used in SBPL (like file-read*, mach-lookup, etc.). This map isn’t part of a single profile blob; rather, it’s derived from system knowledge – the libsandbox.dylib contains a list of operation names, and Apple’s published profiles or reverse-engineering efforts provide these mappings. For tools like XNUSandbox, having this map is essential to turn an “operation 42” in the binary back into a meaningful name in the decompiled SBPL. The map must be maintained as Apple adds new operations or changes them across OS versions.
Concepts.md: Defines Operation Vocabulary Map as the two-way mapping between operation IDs and names. It notes that in practice this map is built from a combination of sources: strings in libsandbox, known system SBPL files, observed behavior, etc., and it emphasizes tracking which mappings are confirmed or still unknown on a given OS version. This hints that not all operations are documented officially, and the project must keep the mapping updated per version.
Orientation.md: Orientation doesn’t explicitly call it a “vocabulary map,” but it does instruct that when decoding, one should tie operation IDs to names using the mapping described in the “Operations and Filters Reference”. Also, Orientation’s guidance for code agents includes: use the operations/filters mapping defined in Appendix, do not invent new semantics for IDs. So it clearly expects a canonical list of operation names to exist and be followed.
Appendix.md: The Appendix contains the “Operations and Filters Reference” section, which effectively serves as the concrete listing of this vocabulary. It lists major operation families and examples. While the Appendix might not present a complete table with IDs (since IDs can vary), it provides the known set of operation names. The actual numeric mapping may be gleaned from open-source or reversing (and is kept in the tool’s code).
ERRATA.md: The “Public headers and symbols” erratum addresses a challenge with maintaining the operation vocabulary map on macOS 14: Apple’s sandbox kext is no longer present at the expected path, so automated extraction of operation names (like using symbols from the kext or libsandbox) doesn’t work. This means the project has to adjust how it finds new operation IDs. The errata suggests those symbols are still present in libsandbox.dylib (even if not declared in headers), but one must prototype them manually. In short, the vocabulary map concept stands, but the way to populate it requires updated methods for newer OS versions.

### Filter Vocabulary Map

Definition: The Filter Vocabulary Map is similar to the operation map, but for filter keys and their possible values. It maps the numeric filter key IDs (and their encoded value representations) in the compiled profile to the human-readable filter names and value meanings (e.g., key ID 3 → literal, expecting a string index; key ID 4 → regex; key ID for vnode-type with a certain enum value means “REGULAR-FILE”, etc.). This mapping is what allows a tool to take a raw filter node (say key=5, value=2) and print it as (vnode-type DIR) or to group filters by category. Maintaining the filter vocabulary means knowing all the filter keys (path, global-name, mach-local, etc.) and how to interpret their arguments (strings, numbers, bitfields).
Concepts.md: Defines Filter Vocabulary Map as the mapping for filter keys and encoded values to their names/semantics. It explicitly mentions that this is necessary for meaningful reconstruction of SBPL filters from raw nodes. It also notes that it lets tools reason about filters by category (e.g., know that certain key IDs are “path-based” filters vs “Mach-related” vs “process metadata”) rather than treating them as opaque numbers.
Orientation.md: Alludes to this concept in Orientation’s early tasks: “Map filter codes/arguments ↔ SBPL filters” is listed as an ability one needs. Also, Orientation’s code mapping advice (section 5.4) says to look for code switching on filter keys and interpreting filter arguments as indices, enums, bitfields, etc., and points to the Appendix for the filter vocabulary. This is essentially instructing how to apply the Filter Vocabulary Map.
Appendix.md: The Appendix’s filters reference is where the filter vocabulary is implicitly documented. It lists the types of filters (path, network, Mach, process, etc.) and often the underlying key names that appear in SBPL. The early format description also enumerated filter_type codes such as path, xattr, mach-local, socket-remote, etc., giving a hint at numeric values. So the Appendix, combined with external references, gives the mapping of filter keys to meanings.
ERRATA.md: There isn’t a direct erratum about filter vocabulary. The main related issue (in the “Public headers and symbols” entry) is that the automated extraction of filter and operation names might be hindered since the kext isn’t accessible. But typically, filter keys might be defined in XNU’s source or known from prior reversing, and Apple tends not to remove filter types frequently. So no major drift noted for filter vocabulary in the errata.

### Policy Stack Evaluation Order

Definition: Policy stack evaluation order describes how multiple sandbox policies are applied in sequence when an operation is checked. In macOS, this order is: first the platform policy, then the per-process policy (if any), and also any other security policies from the MAC framework (Seatbelt is one, but there could be others). The final decision is effectively the logical AND of all applicable policies. In practical terms, this means if the platform sandbox says “deny” for an operation, that decision is final (the app’s own policy won’t even get a chance); if the platform allows it, then the app’s policy is evaluated, and so on. Only if all policies allow the operation does it proceed. This evaluation order is crucial for understanding outcomes, because a seemingly permissible action in an app’s sandbox profile might still be blocked by the global policy.
Concepts.md: Defines Policy Stack Evaluation Order succinctly: platform policy evaluated first, then any per-process policy, and the final decision is the AND of all participating MAC policies. It also notes why this matters – a platform deny short-circuits the app’s rules, and some “mysterious” constraints on apps might actually come from the platform layer.
Orientation.md: Describes this in narrative form. In the Core Model section, Orientation says every process can have a platform policy and an optional process policy. In the runtime Stage 4 description, it outlines: check platform policy first, then per-process policy if present, then require all allowed to proceed. It effectively describes the same logical AND combination and immediate fail on platform deny.
Appendix.md: The Appendix’s policy stacking section directly mirrors this concept. It explicitly states (in text or list form) that when an operation is checked: first the platform policy is evaluated, and if it denies, then it fails immediately (no further checks); if the platform allows, then the per-process policy is evaluated, and if that denies, the operation fails. It even summarizes: effective policy = platform policy ∧ process policy ∧ any other MAC policies. This completely reinforces the logical AND model. The Appendix thereby provides a clear confirmation of the evaluation order.
ERRATA.md: No change to this fundamental order – it’s an architectural constant. The only nuance in errata might be that because sandbox-exec is gone, users can’t easily add arbitrary custom policies, but the stacking of platform and App Sandbox remains. The platform policy still runs first and is still quite potent (and Apple tends to strengthen it over time, which means more operations might be denied globally regardless of app policy).

### Compiled Profile Source

Definition: Compiled profile source refers to where a given compiled sandbox profile blob originates and what it represents. In context, this concept is about distinguishing what the profile under analysis is: is it one you wrote and compiled yourself for testing? Is it a built-in App Sandbox template shipped with the system (like application.sb for third-party apps)? Or is it the global platform profile embedded in the OS? Knowing the source of a profile blob is important because it tells you the intended scope and usage of that policy. For example, a profile from /System/Library/Sandbox/Profiles named ssh.sb would be the sandbox for the SSH service, whereas a blob extracted from the kernel might be the platform policy affecting all apps. It influences how you interpret the rules (some profiles are meant to be combined with others, etc.).
Concepts.md: Defines Compiled Profile Source as where a compiled policy blob came from and what it represents. It gives examples: a profile could be directly compiled from your own SBPL (a test profile), a system .sb file (like App Sandbox templates or specific service profiles), or a platform/global profile embedded in system components. The definition stresses that tracking the source is important for analysis and teaching, since it frames whether you’re looking at a full platform policy or just an app policy, etc..
Orientation.md: Does not explicitly name this concept, but it does implicitly refer to it. Orientation mentions XNUSandbox usually works with compiled blobs from kernelcaches or files – this hints at two sources (kernelcaches for embedded profiles, files for on-disk .sb profiles). The Reading.md document (which maps external sources) also encourages checking Canon.md if external knowledge is allowed, but within local docs, Concepts is where the idea of “what profile am I looking at” is codified.
Appendix.md: The Appendix includes details on where profiles reside across OS versions. It notes that on older iOS, profiles were embedded in the kernel extension; later moved to userland files, then back into a bundled kext blob. It also references system profile locations (the Appendix may mention standard paths like /usr/libexec/sandboxd for older, or simply implies the existence of system .sb files). So the Appendix gives concrete examples of profile sources across versions, aligning with this concept.
ERRATA.md: The “Storage locations” erratum is directly relevant: it updates the knowledge of where profiles are stored on macOS 14.x. It notes that whereas earlier documentation talked about kernelcache extraction, on 14.x the profiles live under /System/Library/Sandbox/Profiles and can be compiled directly (meaning Apple now ships them as files). This confirms a change in compiled profile source availability – now one can get the platform profile from the filesystem rather than scraping it. The erratum emphasizes that previous extraction methods (looking into kernelcache at a specific offset) are obsolete for modern macOS. This is a version-specific detail that should be recorded alongside the concept of compiled profile sources.

### Parameterization (Candidate concept for surfacing)

Definition: Parameterization in SBPL refers to the ability to define sandbox profile rules that accept parameters (variables) to be filled in at profile compile-time or launch-time. Apple’s internal sandbox profiles often use forms like (param "XYZ") inside the SBPL, along with string concatenation (e.g., string-append) to construct resource paths or entitlements dynamically. This allows a single template profile to be reused with different values. For example, the App Sandbox template might have a parameter for an app’s bundle ID or container path. When compiling the profile, the system or tool provides actual strings for these parameters (via APIs like sandbox_compile_file with a parameters dictionary). If parameters are not provided, compilation will fail because the policy can’t be fully resolved.
Appendix.md: Briefly notes that general Scheme constructs exist in SBPL, including conditionals, lambdas, macros, and parameterization. It mentions that Apple’s profiles do use macros and helper functions for reuse and exceptions. However, the specifics of the (param ...) syntax or how parameters are supplied are not detailed in the Appendix cheat sheet.
ERRATA.md: Contains an entry highlighting the parameter issue on macOS 14: “Many system profiles use (param ...) and string-append; compilation without supplying parameters fails… Orientation notes parameters implicitly via the DSL, but practical usage requires passing parameters into sandbox_compile_file”. This erratum makes it clear that this is a known gap – the main Orientation/Appendix didn’t explicitly teach how parameterized profiles work, and in practice one must provide --param values to compile these profiles.
Concepts.md / Orientation.md: Neither explicitly lists parameterization or parameters as a first-class concept. It’s implied (e.g., Orientation Stage 2 notes macro expansion by libsandbox.dylib, which might include handling (param) forms as macros or variables). But a newcomer reading only those might be unaware that certain profiles won’t compile without external inputs.
Why surface this? Parameterization appears to be a standalone concept that is heavily relied upon in real system profiles (especially App Sandbox templates). It is currently only hinted at in Appendix and Errata. Documenting it as a core concept (e.g., adding an entry in Concepts.md or a section in Appendix) would ensure that developers understand that SBPL can have parameters and that using the sandbox compile APIs requires providing those. It would formalize the idea that profiles can be templates needing substitution.
(In the suggestions below, we’ll recommend making this concept more explicit in the main documentation.)

## Frictions and Gaps

Overall, the Seatbelt documentation is internally consistent and reinforces a common model, but a few overlaps and inconsistencies emerge when comparing the files. Below we outline the key invariants that are consistently upheld, areas of overlap where the same concept is described in multiple ways, points of friction or ambiguity between documents, and known drifts between the idealized model and actual macOS behavior.
Core invariants across the docs: The documentation explicitly establishes certain invariants about how to treat the information:
Orientation.md is canonical for the high-level model, and any contradictions found elsewhere should be treated as “drift” to be explained, not as reason to change the model. Similarly, Concepts.md provides the official terminology that code and discussions should stick to, and Appendix.md is the authoritative reference for syntax and formats (agents are told not to guess, but to rely on it). ERRATA.md is strictly for pinning down known deviations and not meant to override the model.
The conceptual model of the sandbox is strongly reinforced: for example, default-deny as the baseline policy is noted in Orientation and shown in Appendix examples (nearly every profile starts with (deny default)). Also, the multi-layer enforcement invariant is consistently described: the platform policy and per-process policy both must allow an operation, with platform denies taking precedence. All sources agree that the effective decision is the logical AND of layers (a deny in the platform layer short-circuits evaluation).
The documents share a unified view of the compiled profile as a decision graph of nodes. Orientation, Concepts, and Appendix all emphasize that a sandbox profile compiles into a graph structure of test nodes and decision nodes. This is an invariant understanding: even though the binary format changed over time, at a conceptual level it’s always a graph of filters leading to decisions.
Overlapping definitions reinforce concepts: Many key concepts are intentionally defined in more than one place using slightly different words, which actually helps solidify understanding:
For instance, Operation is defined in Concepts.md and also introduced in Orientation.md’s quick vocabulary section. Both describe it as a named class of action with an ID and an entrypoint in the compiled graph. There is no conflict here – Orientation gives a brief definition with examples, and Concepts.md gives a fuller definition – together they reinforce what an Operation means.
Similarly, Filter and Metafilter are explained in Orientation (with focus on examples and categories) and formally defined in Concepts.md. The wording differs slightly but the meaning aligns exactly (e.g., Orientation: “predicate on the operation’s arguments or state” vs. Concepts: “key–value predicate that narrows when a rule applies”). This redundancy is deliberate and consistent, not contradictory.
The concept of Decision appears in Orientation’s list and in Concepts.md, both emphasizing allow/deny plus flags. Orientation’s mention that decisions include optional “log/report, user consent” flags matches Concepts.md noting the same modifiers. This overlapping coverage means the documents echo each other, reducing ambiguity.
The policy stacking logic is described narratively in Orientation and more formally in Concepts and Appendix, all in agreement (platform first, then process, AND-combined). Each source’s way of phrasing it overlaps to paint a consistent picture.
In summary, these overlaps are not mistakes but rather reinforced concepts – the documents use multiple angles (tutorial style in Orientation, reference style in Concepts/Appendix) to describe the same ideas. This helps users who might read one file and not the others; wherever you look, you get a consistent definition.
Terminology inconsistencies and normalization: A few terms are used differently in different parts of the docs, requiring readers (or us in this analysis) to normalize them:
The Operation Pointer Table vs. Operation Node Pointers is one example. Concepts.md calls it the Operation Pointer Table, whereas Appendix.md (following SandBlaster’s terminology) refers to an array of Operation Node Pointers. These are the same concept (a table of entrypoints for each operation). This slight naming mismatch could confuse; one has to realize they mean the same structure.
Similarly, a Policy Node in our glossary is sometimes referred to externally as an “operation node” (particularly in Appendix citing SandBlaster). The docs themselves prefer “policy node,” but mention that SandBlaster uses “operation node.” We have to normalize that these are synonyms: a single node in the graph (not specifically tied to one operation, despite that external name).
The word “handler” is also used in older context (Blazakis’s format description) to mean what we now call a node or rule element.
These differences aren’t conceptual disagreements, but they require the reader to map terminology. The documentation assumes a degree of context (e.g., that one reading the Appendix’s format section will understand “Operation Node Pointers” correspond to the op-pointer table concept introduced elsewhere). We explicitly flag these as places where terminology normalization was needed: we had to interpret Operation Node Pointer array as Operation Pointer Table, and operation node/handler as policy node, multiple times during analysis.
Another minor terminology gap is the use of “sandbox profile” vs “sandbox policy.” The Orientation frequently talks about “policies” in the kernel (and even uses the term “policy blob”), while Concepts.md uses the term “profile” for the SBPL and compiled form. In truth, they mean the same thing in context (a compiled profile is a policy). The documents don’t explicitly define “policy” as separate from “profile,” so a reader might wonder if there’s a difference. Generally, one can infer: profile = the rules (static representation), policy = the effect (enforced representation). But this is an implicit understanding. This is a slight ambiguity that could be clarified to avoid any confusion that there might be a semantic difference. (For example, Orientation says “each sandbox policy is a compiled profile” – equating the terms – so it’s clear if read carefully.)
Ambiguities and gaps in coverage: A few areas are under-specified in the main narrative and only become clear when consulting Appendix or Errata:
Parameterization is the clearest gap. Orientation and Concepts did not mention that SBPL allows parameters in profiles, nor how those are handled. Only Appendix gave a one-line hint, and Errata spelled out the issue (profiles with (param ...) won’t compile without providing values). This means someone reading just Orientation/Concepts might be puzzled when they see (param "XYZ") in a system profile. The model in Orientation implicitly assumed a fully specified profile. This is an ambiguity that becomes apparent only in practice – hence it ended up in Errata. It indicates the docs could better explain this feature.
Sandbox initialization APIs and usage: Orientation describes conceptually that a process can have a custom profile via sandbox_init* calls, but it didn’t mention the modern restrictions (that on macOS 14, calling sandbox_apply without privileges fails) – which is fine for the model, but in practice it’s a caveat. Errata covers this. There’s a slight friction in that a reader might assume any process can call sandbox_init to apply a profile (as was true in older macOS), whereas in reality Apple now blocks that for most processes. The documents treat this as drift, not changing the conceptual model (the model assumes the mechanism exists, which it does, but Apple policy prevents its use). It’s an ambiguity only when moving from theory to practice.
Lack of explicit “Seatbelt policy vs other MAC policies” context: The docs focus on Seatbelt itself, but occasionally reference that the final decision is combined with other MAC policies (like AMFI, etc.). This is mentioned in Concepts (logical AND including non-Seatbelt MAC policies). It’s a subtle point that the sandbox is one MAC module among potentially several. Orientation doesn’t delve into others (it stays on Seatbelt). This isn’t a contradiction, just a note that only in Concepts do they explicitly remind the reader that the AND includes others beyond sandbox. It could be missed if one only reads Orientation. So cross-document, it’s helpful that Concepts adds that completeness.
Profile storage evolution vs current state: The Orientation/Appendix describe how profiles have been stored (kernel extension, separate files, bundled blob) up through iOS 9 era. Errata then updates that as of macOS 14, profiles are available as files in /System/Library/Sandbox/Profiles. If one didn’t read Errata, they might think they still need to extract from kernelcache or that Sandbox.kext is loaded from the old path. This is a knowledge gap if using only older info. The docs call it out as errata, which is appropriate, but it is a point of friction (doc vs reality) that had to be resolved by adding Errata.md.
Regex handling: The Appendix assumes the ability to decode regex bytecode (Apple’s libMatch), which historically was possible with the AppleMatch.kext or userland library. The Errata notes that on 14.x, that library isn’t accessible, so the project resorted to a custom solution. This is a minor friction between the expectation set in Appendix (that one could rely on Apple’s regex engine to interpret patterns) and the modern situation. The model of having a regex table is the same, but practically the tooling had to adapt.
Minor overlapping concept: Profile Layer vs Policy Stack Order – These two concepts are closely related (one names the layers, the other describes how they’re applied). They are documented separately, which might cause a reader to wonder how they differ. In practice, Profile Layer is about identifying “this rule is in the platform layer or in the app layer”, while Policy Stack Evaluation Order is about how those layers are processed at runtime. There’s no conflict, but the separation is a bit artificial. A reader might benefit from a cross-reference (which currently isn’t there) to link these ideas. This came up as a minor documentation friction: we had to mentally connect that Profile Layer concept in Concepts is completed by the evaluation order concept later in Concepts and described in Appendix.
Version-specific divergences (model vs macOS 14.x): The ERRATA.md file itemizes these, but they are worth summarizing as frictions between the idealized model and reality:
Sandbox apply and sandbox-exec restrictions: The model (Orientation) says processes can load a compiled profile (Stage 3) via syscalls. On macOS 14.x, Apple locked this down: calling sandbox_apply as an unprivileged user returns EPERM, and using sandbox-exec (which internally tries to apply a profile) will fail. This is a case where the mechanism exists (so the conceptual model isn’t false) but in practice it’s not usable without special permission. The docs treat this as a known deviation to document, not as something to change in the core model. It’s a friction because someone following the docs might try to use sandbox-exec or sandbox_apply and encounter failure – Errata.md is there to catch that and explain why.
Missing public SDK declarations: Orientation assumes that APIs for compiling sandbox profiles exist (and indeed sandbox_compile_file and friends exist, but Apple doesn’t expose them in headers). Errata notes that in Xcode SDK headers, sandbox_compile_* isn’t declared, even though the symbol is present in libsandbox.dylib. This is a nuance for developers: it means you can compile profiles, but you have to declare the function yourself. The conceptual docs didn’t mention this at all – it’s purely an implementation detail caught in Errata. It’s another example of drift (Apple’s documentation vs actual behavior).
New profile format quirk: As mentioned, profiles compiled on modern systems had re_table_offset = 0, which the older understanding didn’t cover. The conceptual model in Appendix includes both old tree and new graph formats, but apparently Apple introduced a slight format change (maybe an optimization or new structure) such that a legacy parser didn’t recognize it. This is friction in terms of tooling – the model of a graph still holds, but the parser logic needed updating. It’s documented as an erratum and indicates an area where the Appendix could be extended to include this variant.
Profile parameters requirement: Many system profiles now are parameterized (especially those in /System/Library/Sandbox/Profiles). The Orientation implied parameters via macros but didn’t explicitly teach how to handle them. The Errata points out you must supply --param when compiling those profiles or else you get errors. This divergence is more about tooling usage than the sandbox’s behavior, but it’s crucial for using the sandbox in practice. It highlights something the main docs glossed over.
AppleMatch and regex parsing: Already discussed – the docs assume regex table can be handled (Appendix describes format), but on macOS 14 the provided mechanism (libMatch library) isn’t available, requiring a workaround. It’s a small friction for tool developers, captured in Errata.
Storage and extraction changes: The shift to shipping human-readable .sb profile files in the OS (macOS 14) vs earlier needing to extract from kernelcache is a divergence. The Orientation/Appendix explained the older method; Errata updates to the new reality. This is actually a positive change (easier to get profiles), but a divergence from what long-time researchers might expect.
In summary, the internal consistency of the sandbox model across Orientation, Concepts, and Appendix is very high – they reinforce the same architecture and vocabulary. The frictions are mostly at the edges: evolving implementation details and slightly differing terminology. The invariants (like default-deny, layering, graph structure) are strongly and repeatedly affirmed. Overlaps in definitions serve to strengthen those invariants, not contradict them. The inconsistencies that do exist are either terminology nuances (which can be fixed by adding clarifications or cross-references) or version-specific behavioral changes (which are documented in Errata but could be more tightly integrated into the main text with notes). By addressing these, the documentation can be made even more cohesive.
