1. ROWESANDBOXING

This paper gives a concrete, implementation-oriented overview of how macOS sandboxing (“Seatbelt”) works from the point where a process opts into sandboxing, through policy specification in SBPL, compilation in libsandbox, and finally enforcement in the kernel via the Sandbox kernel extension and the MAC Framework (MACF). It explains how applications become sandboxed (either via the App Sandbox entitlement or via private sandbox(7) APIs), describes the SBPL policy language and its use of operations, predicates, parameters, and sandbox extensions, and then details how compiled sandbox bytecode is attached to processes and evaluated on each MACF hook. It also sketches the relationship between the platform-wide sandbox policy and per-process policies, and briefly contrasts macOS with iOS and related platforms (where sandboxing is mandatory and custom policies are not supported for third-party apps).

2. Architecture pipeline

From a high level, sandboxing on macOS is implemented by a Sandbox kernel extension that acts as a client of the kernel’s Mandatory Access Control Framework (MACF), and by a family of userspace APIs collectively referred to as sandbox(7). The kernel exposes on the order of hundreds of MACF policy hooks that correspond to system calls and file system operations. The Sandbox kernel extension implements many of these hooks; when one of the corresponding system calls runs, the kernel invokes the Sandbox hook early, passing context about the operation. This hook can then decide whether to allow or deny the operation based on the sandbox policy.

There are two main ways for an application to end up sandboxed. First, an application can explicitly apply a sandbox to itself using the sandbox(7) APIs. These APIs are mostly undocumented and give full control over the policy. Second, an application can opt into the App Sandbox by using a specific entitlement. The App Sandbox is a predefined policy that bases allowed resources on process attributes such as entitlements. The paper notes that the App Sandbox is required for third-party applications distributed via the Mac App Store, and that on other Apple platforms (iOS, iPadOS, tvOS, etc.) sandboxing is mandatory for third-party apps and custom sandbox policies are not available to third parties.

For the App Sandbox pathway, the paper states that an application using the App Sandbox entitlement is sandboxed automatically by initializers in libSystem that run very early during launch. These initializers check process state and arrange for sandboxing before the application’s own code runs. For applications that do not use the App Sandbox entitlement, sandboxing must be applied explicitly from within the process by calling APIs such as sandbox_init_with_parameters. The paper is explicit that it is not possible to sandbox an already-running process from the outside, and that a process that has sandboxed itself cannot later remove the sandbox or apply additional sandbox policies. Sandboxes can be inherited by subprocesses spawned by a sandboxed process.

The translation from a high-level policy to kernel enforcement happens via libsandbox and a dedicated system call. Policies are written in SBPL (a Scheme dialect) and interpreted by libsandbox, which uses a TinyScheme-based interpreter to turn SBPL into a compiled representation (bytecode). When sandbox_init_with_parameters is used, libsandbox evaluates the SBPL string and compiles the resulting state to bytecode, then “asks the Sandbox kernel extension to apply the sandbox to the current process.” For the explicit compile/apply split, sandbox_compile produces bytecode and sandbox_apply attaches it. In both cases, the sandbox policy reaches the kernel via the __mac_syscall system call, often through a wrapper named __sandbox_ms. The Sandbox kernel extension performs basic validation and associates the policy with the process’s kernel representation via a MAC label.

At enforcement time, when a system call or other MACF-mediated operation occurs, the kernel calls the appropriate Sandbox MACF hook. The Sandbox hook maps the low-level MACF hook to a logical “sandbox operation type” that describes the attempted operation. This mapping provides an indirection layer between kernel hooks and sandbox operations. The operation is first evaluated against a platform sandbox policy that applies to all processes. If the platform policy denies the operation, the denial is propagated back through the MACF hook and the system call returns an error. If the platform policy allows it, the Sandbox kernel extension retrieves any sandbox policy associated with the process (via its MAC label) and evaluates that policy. If the process has a policy and it denies the operation, the denial is returned; if there is no process policy, the operation is permitted (subject to the platform policy only).

3. Language and policy model (as seen here)

The paper describes sandbox policies as written in SBPL, a dialect of Scheme. At the source level, a policy consists of a default action and a series of allow/deny declarations for specific operations, each decorated with predicates that must match for the action to apply. A default action is specified using a form such as `(default deny)` or `(default allow)`, and operation-specific rules are expressed with forms such as `(allow file-read* (path "/tmp/foo") (subpath "/tmp/bar"))`. The default action governs any operation instances that do not match an explicit allow/deny clause.

Operations in SBPL are named, higher-level abstractions corresponding to categories of actions (e.g., file-read, file-write, sysctl, Mach bootstrap lookup) rather than raw system calls. For each operation, the policy uses an `allow` or `deny` form, takes the operation name, and then supplies zero or more predicates. A simple example in the paper shows a default-deny policy that: allows reading from a specific file and directory subtree, allows a particular sysctl by name, and allows file creation under a path provided that the file is not a symlink. This uses predicates such as `path`, `subpath`, `vnode-type`, and higher-level combinators like `require-all` and `require-not` to express conjunction and negation. The model is an explicit allow/deny decision on an operation, conditional on a conjunction of predicates.

Because SBPL is a Scheme dialect, it inherits full programming-language constructs: conditionals, loops, lambdas, and macros. The paper emphasizes that SBPL supports passing string-valued parameters from the embedding application to the policy. These are accessible via the `param` function at evaluation time, enabling a single SBPL template to be configured differently per process instance. The example given defines a parameter (e.g., `"SHINY_NEW_DOWNLOADS_ENABLED"`) and uses a Scheme `if` form to conditionally install additional rules based on its value, such as granting read/write access to a “Downloads” directory only if the parameter equals a specific string.

The model also integrates sandbox extensions at the policy level. SBPL rules can include predicates that test for the presence and class of a sandbox extension, using an `extension` predicate in combination with path-based predicates such as `subpath`. For instance, an example policy allows file reads only if both (a) the path lies under a particular Downloads directory and (b) a sandbox extension of a particular class is present. In this way, extensions become dynamic preconditions on otherwise static allow rules.

Finally, the policy model includes “action modifiers” that adjust the side-effects of allow and deny decisions. At the SBPL level these appear as modifiers on the action, e.g., `(allow (with report) sysctl ...)` to request a violation report even when the action is allowed. The paper later ties these modifiers to concrete behaviors such as overriding errno on deny, suppressing or enabling reporting, logging, sending signals, or triggering internal telemetry. The core model, however, remains: per-operation rules, written in SBPL, combining predicates over operation context and process/environment attributes, with an explicit default and optional modifiers on actions.

4. Compilation, internal format, and enforcement mechanics

On the userspace side, the paper states that SBPL policies are “interpreted via an interpreter within libsandbox, based on TinyScheme, which generates a compiled representation of the policy that it passes to the Sandbox kernel extension.” When sandbox_init_with_parameters is used, libsandbox takes the SBPL source string and an array of parameters, evaluates the SBPL using the interpreter, and compiles the resulting state into policy bytecode. That bytecode is then submitted to the Sandbox kernel extension as part of applying the sandbox to the current process. For repeated use of the same policy, sandbox_compile and sandbox_apply allow splitting compilation and application: sandbox_compile produces the bytecode once, which can be cached, and sandbox_apply later reuses this precompiled bytecode when sandboxing additional processes.

In the kernel, the policy is represented as a bytecode program. The paper describes the structure as “a list of bytecode instructions, and a mapping from sandbox operation to the initial bytecode instruction to be evaluated for that operation.” For each sandbox operation type, the mapping gives the index of the first instruction to execute during evaluation. There are two kinds of instructions: filter instructions and action instructions. A filter instruction consists of a predicate and two instruction indices: a “match” target and a “not match” target. When a filter executes, if its predicate evaluates to true on the current operation’s context, evaluation jumps to the “match” instruction; otherwise it jumps to the “not match” instruction. This gives the kernel a general branching structure over predicates, effectively an explicit decision graph.

Action instructions encode the final decision. An action may be either allow or deny, and can carry zero or more modifiers that affect side effects. When evaluation reaches an action instruction, evaluation for that operation stops, and the action is taken: the Sandbox kernel extension permits or denies the underlying MACF operation, and the modifiers are applied. The paper notes behaviors tied to modifiers, such as allowing deny-actions to override the errno value returned, suppress reporting, send a signal to the offending thread, or trigger internal telemetry; and allowing allow-actions to generate violation reports, log messages to the system console, or trigger telemetry. The policy text controls these modifiers via SBPL constructs like `(with report)`, `(with message "…")`, or `(with EBADEXEC)`.

The predicates available in filter instructions mostly inspect the operation’s context. For file system operations, the paper cites predicates such as `path` and `vnode-type` to match on path strings and vnode types. For sysctl system calls, predicates such as `sysctl-name` match on the name of the sysctl being accessed. For Mach bootstrap lookup operations, predicates such as `global-name` and `local-name` match on bootstrap service names. Additional predicates examine attributes of the process itself—for example, `signing-identifier` or `entitlement-is-present`—and system-wide state, such as `csr` predicates for System Integrity Protection settings or `system-attribute` for other global attributes. The paper notes that these latter predicate groups are primarily used in policies that apply to multiple applications, such as the platform sandbox policy or the App Sandbox, rather than single-application policies. The paper does not specify the exact binary encoding of predicates, operation IDs, or instruction indices.

Enforcement mechanics tie this bytecode to MACF hooks. When a relevant system call is made, XNU invokes the Sandbox kernel extension’s MACF hook and supplies the operation context (arguments and related metadata). The Sandbox hook translates the concrete MACF hook into a logical sandbox operation type. It then evaluates the platform sandbox policy’s bytecode for that operation. If that evaluation produces a deny action, the error is returned immediately to the system call via the MACF machinery. If the platform policy allows, the Sandbox kernel extension looks up any per-process sandbox policy associated with the process via its MAC label. If a process policy exists, it runs the bytecode linked to that operation; if the process is unsandboxed, that second phase is skipped and the operation is allowed (subject only to the platform policy). By default, denied operations fail with EPERM, the kernel logs a message, and sandboxd may produce a violation report with a thread backtrace; action modifiers can change these behaviors, but the paper does not describe the internal plumbing for logging or reporting beyond this.

5. Patterns and implications for a capability catalog

The paper emphasizes a default-deny, allow-list idiom. Policies are expected to block most operations by default and then whitelist those needed for normal execution. This is reflected in SBPL via `(default deny)` plus per-operation `allow` forms. The examples show fine-grained controls: tightly scoped file access (one file, one subtree), specific sysctls, or constrained file-creation rules that disallow symlinks. For profiling capabilities, this suggests that “capability” is not just “operation X is allowed” but “operation X with particular predicates is allowed,” especially for file and sysctl operations.

Another structural pattern is the layering of platform and per-process policies. Every operation is first constrained by a platform sandbox policy that applies to all processes and is then optionally further restricted by the process sandbox. Thus, there exist operations that are disallowed globally regardless of any process policy. Inference: for a capability catalog, this implies a separation between capabilities controlled at the system/platform level and those controlled at the application level; the latter can only refine (not override) the former.

The policy model is predicate-heavy. For capabilities involving files, sysctls, or Mach names, predicates such as `path`, `subpath`, `vnode-type`, `sysctl-name`, `global-name`, and `local-name` are central. This means that multiple distinct capabilities can share the same logical operation type but be distinguished entirely by predicates. Inference: any capability catalog that works at the sandbox operation level alone will be too coarse; the catalog must treat predicate structure (e.g., which path prefixes, which bootstrap names) as part of the capability definition.

Sandbox extensions introduce a distinct pattern: dynamic delegation of capability. A more privileged process issues an opaque token representing access to a specific resource (e.g., a file path or Mach bootstrap name) under a specific “extension class,” and passes this token to the sandboxed process. The sandboxed process consumes the token, and SBPL rules can require (via `extension` predicates) that such a token be present to allow an operation. The paper’s examples cover familiar cases such as granting temporary file access from a file-open dialog, or limiting extensions to a specific directory subtree. Inference: for a capability catalog, static policy inspection is insufficient for all capabilities; some capabilities are latent and only become effective when particular extension classes are issued at runtime, so the catalog should treat extension classes as capability-bearing entities.

Finally, the use of parameters, Scheme-level control flow, and action modifiers makes policies both programmable and introspective. Parameters allow a single SBPL source to encode a family of related policies; predicates over entitlements and signing identifiers allow policies such as the App Sandbox to branch on caller identity; modifiers control how violations and even successful operations are surfaced (or suppressed). Inference: for capability cataloging, this means that a single “operation” can have different effective capabilities depending on parameter values, entitlements, and system state, and that cataloging should include not just whether an operation can occur but also whether it is observable (e.g., via reporting or logging) and under what contextual predicates it is enabled. The paper, however, does not provide concrete examples of these context-dependent variations beyond the few SBPL snippets and does not enumerate the complete operation or modifier sets; those details would need to be obtained from other sources.
