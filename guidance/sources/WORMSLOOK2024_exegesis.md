1. WORMSLOOK2024

WORMSLOOK2024 is a modern, implementation-focused tour of Apple’s Sandbox on macOS and iOS, with particular emphasis on how containers, entitlements, sandbox profiles, and MACF-based kernel hooks fit together into a working system. It explains which processes are sandboxed on each platform, how container directories and their metadata (including embedded profile blobs) are created and managed, how libsystem_secinit and libsandbox decide whether and how to initialize a sandbox at process startup, and how Sandbox.kext uses MACF hooks, per-credential sandbox labels, and a central evaluator to enforce the policy, including the use of sandbox extensions to delegate capabilities like file access across process boundaries. 

2. Architecture pipeline

At the top of the pipeline are code-signing and entitlements. On both macOS and iOS, entitlements are a property list embedded into the signed binary, expressed as key–value pairs that declare what capabilities the system should grant (for example, printing, network access, or iCloud sync). WORMSLOOK2024 highlights com.apple.security.app-sandbox as the key entitlement on macOS: when set to true, the app is voluntarily asking to be sandboxed. On iOS, the controlling entitlement for opting out is com.apple.private.security.no-sandbox: if this is present and set to false, the application is explicitly told not to bypass sandboxing, and for third-party apps this effectively means “always sandboxed,” since only Apple can meaningfully use this entitlement. The paper stresses that Apple’s own signed apps can use many private entitlements, while third-party apps are constrained to a documented subset.

Entitlements are best read as declarative inputs to sandbox policy rather than permissions that bypass it. Platform-wide and app-specific sandbox profiles consult these entitlement keys when deciding whether to allow operations such as camera, network, or iCloud access, so the entitlement informs the policy engine instead of directly opening the capability. com.apple.security.app-sandbox is special: setting it to true opts a macOS process into the App Sandbox model rather than granting a capability. On iOS, third-party apps (App Store or similar) are always sandboxed, and com.apple.private.security.no-sandbox is a private, Apple-only escape hatch that only Apple-signed system binaries can meaningfully use to run unsandboxed.

Process launch next runs through dyld and libSystem. Every process is started by the dynamic linker dyld, which loads libSystem and, as part of that, libsystem_secinit. WORMSLOOK2024 describes libsystem_secinit as the user-space component that decides whether a process “should be sandboxed,” based exactly on those entitlements: on macOS it looks for com.apple.security.app-sandbox being present and true, and on iOS it checks the com.apple.private.security.no-sandbox entitlement instead. If the rules say the process ought to be sandboxed, libsystem_secinit then arranges for libsandbox to be loaded and invoked so that a sandbox profile can be prepared and installed before user code starts to execute.

Containers sit alongside this as the filesystem embodiment of the sandbox. On macOS, when a sandboxed app first runs, the system creates a per-app container directory at ~/Library/Containers/<applicationID>. That container is lazily created on first launch if it does not already exist, and its internal layout mirrors a home directory (Documents, Library, Downloads, etc.) so that an app can treat it as a private home. On iOS the split is more complex: there is a “bundle container” under /var/containers/Bundle/Application/{UUID} for static app resources (assets, binaries, frameworks) that do not change between runs, and a “data container” under /var/mobile/Containers/Data/{UUID} for runtime data that the app can freely read and modify. iOS creates these containers at install time (not at first launch), and then fixes up environment variables like HOME and TMPDIR to point into the container so that regular filesystem APIs naturally land inside the sandbox.

Containers and the sandbox are related but distinct: containers define where on disk the app can freely read and write by default, while the sandbox is the kernel MACF policy enforced by Sandbox.kext that mediates filesystem, network, IPC, device access, and more. Equating “sandbox == container” misses that the container is only the filesystem facet of a broader policy, and the same sandbox evaluator covers operations that have nothing to do with the container.

The paper foregrounds the daemon containermanagerd and its private framework ContainerManagerCommon.framework as the core of container management. For each iOS app, containermanagerd creates and maintains a metadata property list in the container that includes keys such as MCMMetadataIdentifier (the app identifier), MCMMetadataInfo (a dictionary of general metadata), SandboxProfileData (a base64-encoded sandbox profile for the app), and SandboxProfileDataValidationInfo (inputs libsandbox will later use to compile that profile). containermanagerd speaks XPC to userland clients that install, restore, or remove apps, and also talks to the kernel over a special Mach port to provide container directory information when Sandbox needs it.

At the kernel boundary, everything is mediated by MACF and Sandbox.kext. WORMSLOOK2024 explains that Apple’s Sandbox is implemented as a TrustedBSD MACF policy module registered via mac_policy_register, with a mac_policy_conf that names the policy and a mac_policy_ops table listing all the hooks it implements. For each security-relevant operation (such as opening a vnode for write, connecting a socket, or forking), the kernel calls out to every registered MACF policy that has provided a hook for that operation. The Sandbox policy has hooks for 159 operations on current macOS releases, a subset of the roughly 331 MACF operations available overall, and those hooks all funnel into a central helper function cred_sb_evaluate.

Each hooked operation is evaluated by all registered MAC policies, so the app’s sandbox profile is only one layer in a stacked decision. Apple also ships platform-wide sandbox profiles (including SIP/rootless hardening) that apply across processes and are evaluated alongside any app-specific profile. The net effect is deny-on-any-deny: if the platform profile, the app’s sandbox, or another MAC policy says no, the kernel blocks the operation even if another layer would have allowed it.

Process sandboxing proper happens in the cred_label_update_execve MACF hook, which WORMSLOOK2024 identifies as the “star of the show.” When a process is about to exec a new image, this hook runs in Sandbox.kext and performs several tasks. First, it asks AppleMobileFileIntegrity (another subsystem) for the process’s entitlements so it can read values like the seatbelt-profiles entitlement on iOS and the application identifier. Based on these entitlements and the platform, it decides which sandbox profile to use. It then calls platform_set_container to set up the process’s container association, allocates a sandbox struct that will hold all per-process sandbox state, and issues sandbox extensions that let the process access its own executable and container (so it can at least read its own code and data). Finally, it calls label_set_sandbox to store a pointer to this sandbox struct into slot 1 of the process’s cr_label (the MACF label field in the kauth_cred_t credentials). From this point on, any MACF hook that Sandbox implements can retrieve the sandbox struct using label_get_sandbox and pass it into cred_sb_evaluate along with an operation code and an argument buffer, so that the central evaluator decides allow/deny for each operation.

3. Language and policy model (SBPL as seen here)

WORMSLOOK2024 treats sandbox profiles as the declarative layer that maps entitlements and container scoping into concrete allow/deny rules. A profile is a set of rules; each rule has three main pieces: (1) an action (allow or deny), (2) one or more operations, and (3) optional contextual filters. There is also a mandatory default rule that says what to do when no specific rule matches (allow or deny “default”). Profiles are expressed in the Sandbox Profile Language (SBPL), a Scheme-inspired embedded DSL.

On macOS, profiles are stored as human-readable .sb files under /System/Library/Sandbox/Profiles. WORMSLOOK2024 gives an example profile that imports “system.sb,” declares (version 1), sets (deny default) as the default rule, then adds specific allows and denies. In paraphrase, it allows all file read and write operations within a particular subdirectory of the user’s home directory, allows process-exec only for binaries under a helpertools subdirectory of the app’s container, and unconditionally denies device-microphone and device-camera. This example illustrates three things: operations are grouped into families like file-read* and file-write*; filters like home-subpath and container-subpath scope those operations to paths relative to the user’s home or the app’s container; and some operations represent higher-level capabilities (like device access) rather than simple syscalls.

WORMSLOOK2024 notes that operations are organized into categories such as file-read*, file-write*, process-exec, process-fork, network-inbound, network-outbound, and more granular members like file-write-data or file-write-setugid. A rule can reference a whole family (e.g., file-write*) or a particular member (file-write-data) depending on how fine-grained the policy needs to be. Filters support several kinds of arguments: string literals for exact paths, macros like home-subpath or container-subpath for paths relative to logical roots, and regular expressions to match whole classes of paths. For non-filesystem resources, there are domain-specific filters: for example, user-preference rules can be scoped to a particular preferences domain identifier, and network rules can distinguish local vs remote endpoints even though IP-level filtering itself is not very rich in this language.

The paper also emphasizes that the Sandbox policy layer extends beyond MACF’s own operation list. WORMSLOOK2024 lists several operations that Sandbox polices in its own namespace: appleevent-send controls whether a process can send Apple Events to other processes on macOS; lsopen controls whether a process may open another app via LaunchServices; nvram covers reading and modifying NVRAM variables; and user-preference controls whether a process can read or write preferences belonging to another app (for example, allowing an app to read com.apple.Messages preferences via an allow user-preference-read rule on that domain). These are still expressed in SBPL as operations, but their enforcement path is not always a simple MACF syscall hook.

Entitlements and profiles connect in two ways in WORMSLOOK2024. On iOS, the seatbelt-profiles entitlement directly names or configures which sandbox profile an app should receive; the container metadata’s SandboxProfileData and SandboxProfileDataValidationInfo are the concrete representation of that choice, and libsandbox uses them as inputs when compiling the profile that Sandbox.kext will apply. On macOS, com.apple.security.app-sandbox is the gate that decides whether any profile is applied at all; other entitlements (such as those granting network, printing, or iCloud capabilities) inform how libsandbox builds or selects a profile for that process, although WORMSLOOK2024 does not enumerate the exact mapping from each entitlement to profile rules. Inference: the presence or absence of particular entitlements controls which SBPL operations are allowed in the resulting profile, especially for high-level device and network capabilities.

Finally, WORMSLOOK2024 points out that SBPL is also used for system-level hardening. A key example is System Integrity Protection (“SIP” or “rootless”), whose implementation is “partially just a Sandbox profile” called platform_profile stored as rootless.conf under /System/Library/Sandbox. This profile denies writes to critical system paths like /System, /bin, and certain app bundles, and does so even for many privileged processes, showing that the same language is used to express both app-level containment and system-wide write protections.

4. Compilation, internal format, and enforcement mechanics

WORMSLOOK2024 describes the data flow from on-disk profile and container metadata to kernel enforcement without fully specifying the internal binary format. On iOS, compiled sandbox profiles are stored as opaque binary blobs in the __TEXT.__const segment of Sandbox.kext; on macOS, SBPL text profiles from /System/Library/Sandbox/Profiles are read and compiled by libsandbox at app launch time. In both cases, the paper treats the compilation stage largely as a black box and focuses on how the compiled result is used. The only explicit structural details are that iOS container metadata includes SandboxProfileData (a base64-encoded profile blob) and SandboxProfileDataValidationInfo (a dictionary of parameters libsandbox will feed into its compiler), and that Sandbox.kext expects to receive a compact representation that can be evaluated by its internal engine.

Once a compiled profile has been prepared and the process is being exec’ed, the cred_label_update_execve MACF hook in Sandbox.kext constructs a sandbox struct for the process. WORMSLOOK2024 explains that this struct is stored in MACF label slot 1 inside the process’s kauth_cred_t via label_set_sandbox. The credentials (cr_label) thus carry a pointer to the active sandbox state. To enforce the profile, all Sandbox MACF hooks follow the same pattern: they are passed the credentials, a description of the resource being accessed (for example, a vnode pointer for a filesystem operation, or a socket for network operations), and sometimes additional context. The hook first calls label_get_sandbox to retrieve the sandbox struct, then calls cred_sb_evaluate, passing the sandbox pointer, an internal operation number identifying what is being attempted, and a buffer containing any extra arguments (such as a path, a Mach service name, or a preferences domain).

cred_sb_evaluate is the central entry point to Sandbox’s evaluator. According to WORMSLOOK2024, it always starts by retrieving the sandbox label via label_get_sandbox, then passes control to sb_evaluate_internal along with the sandbox struct, operation number, argument buffer, and a callback function pointer called eval. sb_evaluate_internal performs common pre-processing: it builds the evaluation context (which includes the process’s credentials, its container path, any active sandbox extensions, and the operation’s arguments), then calls eval, a large evaluator function that implements the rule engine. WORMSLOOK2024 notes that eval is on the order of 1800 decompiled lines and is responsible for walking the compiled profile representation, matching operations and filters, and returning allow (0) or deny (a non-zero errno, typically EPERM) back to sb_evaluate_internal, which then passes the result back through cred_sb_evaluate to the MACF hook.

Sandbox extensions add another layer into this internal representation. WORMSLOOK2024 describes extensions as tokens (strings) representing grants for a specific action, such as reading or writing a particular file path, accessing a Mach port, or similar. A process that already has access to a resource can call sandbox_extension_issue_<kind> or sandbox_extension_issue_<kind>_to_process, passing an extension type number and an “extension class” string that further narrows capabilities (for example, whether the file access is read-only vs read–write). The kernel then creates a token string. The issuing process can either keep and later “consume” this token itself, or pass it (e.g., via IPC) to another process that would not otherwise be able to perform that operation. When a process consumes an extension token, Sandbox.kext associates that extension with the process’s sandbox struct so that future calls to cred_sb_evaluate can see that an otherwise-disallowed operation has been temporarily granted via an extension. WORMSLOOK2024 emphasizes that extensions are only meant to grant capabilities that some other trusted actor already had (the Open/Save panel case is the main example), and that the underlying system checks require the issuer to already have the requested capability when creating the extension.

The issuer must already have access to the resource; Sandbox will not mint an effective extension for something the issuer itself cannot reach. The receiving process has to explicitly consume the token via the sandbox/extension API before the extra right is considered during evaluation; merely receiving the string does nothing. Extensions are bound to the process identity and embed a value derived from a boot-time secret, so tokens are not meant to be reused by other processes and naturally become invalid across reboots. These constraints keep extensions narrow, time-bounded delegation hooks rather than general-purpose bypasses.

The enforcement path for a typical operation therefore looks like this in WORMSLOOK2024’s account: a syscall or high-level operation (open, connect, Apple Event send, preferences access, etc.) triggers a MACF hook or a Sandbox-specific interception point; that hook builds an argument buffer and calls cred_sb_evaluate; cred_sb_evaluate retrieves the process’s sandbox struct and forwards the operation identifier and arguments to sb_evaluate_internal; sb_evaluate_internal invokes eval on the compiled profile while also considering any active sandbox extensions; the evaluator returns allow or deny; and Sandbox.kext then permits the kernel to proceed with the operation or returns an appropriate errno to user space.

5. Patterns in built-in profiles

WORMSLOOK2024 does not catalog all of Apple’s built-in profiles exhaustively, but it does highlight several idioms that matter for understanding capability boundaries. Most prominently, SBPL profiles almost always begin by setting an explicit default action (either (allow default) or (deny default)) and then layering specific exceptions. System-level hardening profiles like platform_profile for SIP use a default-allow model for most operations but add denies for writes to critical system paths, effectively creating a “write-restricted but generally readable” system. App-level profiles for the App Sandbox tend to do the opposite: they use (deny default) and then selectively allow operations within the app’s container, within user-selected locations via sandbox extensions, or to specific system services.

Another pattern WORMSLOOK2024 illustrates is heavy use of operation families plus path filters to describe filesystem capabilities. Instead of enumerating every individual write operation, profiles often use file-write* combined with filters like home-subpath, container-subpath, or regex-based path matches. This lets a single rule express “all writes under the app’s container” or “all reads and writes under ~/Documents/SecretDirectory” compactly. For system profiles, similar patterns appear: rules allow a set of paths for reading library code (/System, /usr/lib, dyld cache directories) while denying writes everywhere except a few well-chosen locations. For someone building a capability catalog, this means that a large class of file capabilities are path- and container-scoped rather than entitlement-scoped: the entitlement decides that an app should be sandboxed, but the concrete allowed paths come from SBPL rules that mostly reference containers and well-known directories.

WORMSLOOK2024’s discussion of higher-level operations like device-microphone, device-camera, appleevent-send, lsopen, nvram, and user-preference shows a complementary pattern: these capabilities are mostly entitlement-driven. The profiles in the paper’s examples unconditionally deny device-microphone and device-camera for an app that does not need them; in practice, other apps would only get these operations allowed when specific entitlements are present. The user-preference operation is similarly scoped to particular preference domains, so that even if the operation is allowed, it is limited to identifiers explicitly named in the profile. Inference: for cataloging purposes, many device- and IPC-related capabilities should be treated primarily as entitlement-gated operations, with SBPL providing contextual scoping (for example, only to specific preference domains or Mach service names).

Finally, the use of sandbox extensions in WORMSLOOK2024’s examples (notably the Open/Save panel pattern and self-sandboxing processes that pre-issue extensions) shows a third pattern: some capabilities are neither purely entitlement-driven nor static profile-driven, but are dynamically delegated at runtime. Access to arbitrary user-selected files outside the container, or to resources held by a privileged helper, falls into this category. For a capability catalog, WORMSLOOK2024 implies that one must distinguish (a) baseline capabilities available from entitlements and static profiles, (b) container-scoped path capabilities available by default, and (c) extension-mediated capabilities that appear only when a cooperating privileged component chooses to grant them.
