### 2.3 Tracing real operations through the sandbox

The previous sections treated TextEdit’s sandbox as a static object: a profile, a container, and a set of entitlements that together define what the process is allowed to do. This section turns that picture sideways. Instead of reading the profile and imagining behaviour, we start from concrete actions—opening a document, autosaving, printing—and follow how those actions appear in trace output and how they are accepted or rejected by the sandbox.

The goal is not to build a full tracing harness here. It is to sketch a small set of scenarios that you can instrument with `fs_usage`, `opensnoop`, or similar tools, and to show how you would connect those traces back to specific SBPL rules and concepts in the TextEdit profile. Even without real captures, you can reason about what *should* show up if the profile is doing what it claims.

#### 2.3.1 Opening an existing document in `~/Documents`

Consider the most ordinary action: the user launches TextEdit, chooses **File → Open…**, navigates to `~/Documents`, and opens a file.

From the user’s perspective, this is simple. From the sandbox’s perspective, several distinct things are happening:

1. **User selection and extension issuance.**
   When the user confirms the open panel, the system grants TextEdit a sandbox extension for the chosen path. This step is enabled by the user-selected file entitlements and the corresponding rules in the profile that allow TextEdit to talk to the scoped bookmarks agent and to accept extensions for arbitrary paths.

2. **First file open.**
   With an extension in place, TextEdit performs the actual `open` or `openat` syscall on a path under `~/Documents`. In a filesystem trace you would expect to see a small burst of `open`, `stat`, and `read` operations against that path. The sandbox checks each of these operations against the current set of extensions and the profile’s file rules; because the path carries a valid extension, `file-read*` is allowed.

3. **Ongoing access.**
   As the user edits the document, TextEdit continues to read and write the file. Depending on implementation details, you may see writes to a temporary file, renames, or atomic replacement of the original file. In all cases, the key point is that the subsequent operations still flow through the same extension-based gate: the sandbox does not forget that this path was approved.

In a trace, you do not see “extensions”; you see syscalls and paths. The way to connect the trace back to the profile is:

* The presence of user-selected file entitlements explains why TextEdit can obtain extensions for arbitrary user-chosen paths.
* The specialized SBPL contains rules that treat extension-bearing paths as eligible for `file-read*`, `file-write*`, and `process-exec`.
* Accesses to `~/Documents/...` in the trace, outside the container root, therefore correspond to a combination of entitlement-driven extension logic and general file rules, not to any explicit allow on `~/Documents` itself.

This is the first important lesson: for user-chosen locations under the home directory, **the profile cares more about the presence of an extension than about where the path lives**.

#### 2.3.2 Creating and autosaving a document in the container

Now compare that with a document created in TextEdit’s own container. Suppose the user chooses **File → New**, types some text, and saves to the default location offered by the application (often somewhere under `~/Library/Containers/com.apple.TextEdit/Data`).

Here the trace would look different:

1. **No extension handshake.**
   The container path is already within TextEdit’s primary write zone. The profile’s container macros (`appsandbox-container-common`, `appsandbox-container-macos`) have set up broad `file-read*`, `file-write*`, and directory-content rules under the container root. The sandbox does not need an external extension to permit access there.

2. **Container-local I/O.**
   In a trace you would see files created and written under paths that match the container root and its `Data`, cache, or temp subdirectories. Autosave iterations would appear as periodic writes to those paths, possibly with temporary filenames and renames, but always within the container tree.

3. **Stable invariants.**
   Because the profile treats the container as TextEdit’s private filesystem, the pattern of syscalls here is governed almost entirely by the container macros and the `application_darwin_user_dir`, `cache_dir`, and `temp_dir` parameters. Entitlements play much less of a role; the profile would look very similar for any other sandboxed app with the same container configuration.

This means that a trace of “new document in the container” is an exploration of **how the generic app sandbox template handles containers**, not of TextEdit’s special privileges. If you compare open/save traces for container paths and for `~/Documents`, you can see precisely where the sandbox draws the line between “internal state” and “user-controlled locations”.

#### 2.3.3 External volumes and network shares

A third useful scenario is opening or saving a document on an external volume or network share: for example, a mounted USB drive under `/Volumes/MyUSB` or a share mounted under `/Volumes/ServerShare`.

From the sandbox’s point of view, these paths are just “outside the container and outside the home directory”. The profile does not contain broad allows for `/Volumes`; if TextEdit were to attempt file access there without an extension, the operation would be denied.

The sequence looks like this:

1. The user navigates to the external volume in the open or save panel and selects a file or target location.
2. The system grants TextEdit an extension for the specific path chosen.
3. With that extension, TextEdit performs file operations on `/Volumes/...`, which the sandbox permits because the extension satisfies the relevant predicates in the file rules.

In a trace, this appears as:

* `open`, `read`, `write`, etc. on paths under `/Volumes/...`.
* No special treatment of `/Volumes` in the SBPL; instead, a reliance on the extension machinery that was already in play for `~/Documents`.

The underlying invariant is the same as for home-directory files:

* **The profile does not encode “external volume” as a special case.**
  It encodes “paths with valid extensions” as a special case. External volumes, network shares, and other non-container locations all pass through the same gate.

#### 2.3.4 Printing a document

Printing is more structurally interesting because it combines filesystem activity with a number of IPC interactions.

When the user prints a document from TextEdit, a trace would show:

* Activity on temporary or spool-like files, possibly under `/private/var` or in a print spool directory.
* Connections to the printing pipeline via sockets or Mach services.
* Possibly additional reads of the document being printed, if it is re-rendered for the printer.

The sandbox profile explains why this works:

* The `com.apple.security.print` entitlement is set for TextEdit.
* This entitlement activates the `(printing)` macro in the profile, which in turn allows:

  * `mach-lookup` to printing-related services and daemons.
  * `file-read*` and `file-write*` on certain spool and configuration paths.
  * The necessary authorizations to interact with CUPS or its macOS equivalents.

At the same time, the profile enforces limits:

* Without the print entitlement, there would be denies on certain sockets (for example, localhost:631) and print-related control paths.
* For TextEdit, those denies either do not apply or are structured so that legitimate printing flows go through well-defined channels rather than arbitrary network connections.

In other words, a print trace is a visible manifestation of a **macro-controlled capability**. The profile does not enumerate all print-related operations inline; it delegates to a macro, and that macro is only present because the entitlement is set. When you see printing-related activity in a trace, you are seeing the expansion of that macro in action.

#### 2.3.5 Fonts, dictionaries, and other shared resources

Rendering a document in TextEdit requires access to fonts, dictionaries, ColorSync profiles, and other shared resources. A trace of “open a document and scroll around” would typically show:

* Reads from `/System/Library/Fonts` and `/Library/Fonts`.
* Reads from `/Library/Dictionaries` and possibly networked dictionaries.
* Reads from `/Library/ColorSync/Profiles` and related paths.

The specialized profile contains broad `file-read*` rules for these areas:

* System fonts and dictionaries are readable.
* User fonts and dictionaries under `~/Library/...` are also readable.
* ColorSync profiles and related assets under `/Library/ColorSync` are readable.

These rules are not unique to TextEdit; they reflect a general pattern for GUI apps that render text and graphics. In the context of this section, they serve as good examples of **read-only access to shared infrastructure**:

* A trace shows a sequence of `open` and `read` calls into these directories.
* The corresponding SBPL rules show that these reads are allowed but writes are not.
* Nothing in the entitlements is specific to fonts or dictionaries; the capability is encoded entirely in the generic app profile.

Following these events through a trace helps make the profile’s distinction between “read-only system resources” and “writable app/container data” more concrete.

#### 2.3.6 Optional iCloud flows

An optional scenario involves saving to or opening from TextEdit’s iCloud container. In practice, this means interacting with paths that live under a ubiquity-managed hierarchy, filtered by the identifier `com.apple.TextEdit`.

In a future trace capturing such a scenario, you would expect to see:

* File activity under paths that resolve through the `ubiquity-filter "com.apple.TextEdit"`.
* Background activity from sync daemons writing or reading those files.

The profile’s array entitlement and specialized rules explain why this is allowed:

* The `com.apple.developer.ubiquity-container-identifiers` entitlement lists `["com.apple.TextEdit"]`.
* The SBPL uses that list to generate rules that:

  * Allow `file-link` and read/write operations for those filtered paths.
  * Issue extensions for them as needed.

Until real iCloud traces are captured, this remains a planned scenario, but it fits the same template: **the profile encodes “your ubiquity container” as a specific, filtered region, not “iCloud” in general**.

#### 2.3.7 Using traces as a teaching tool

At the time of writing, the tracing scripts are scaffolding and the traces themselves are placeholders. Even so, the planned scenarios and expected mappings are enough to illustrate how you can use traces as a teaching tool:

* Each scenario (open in `~/Documents`, autosave in the container, external volume, print, render, iCloud) corresponds to a small, focused trace that exercises a different slice of the profile.
* For each trace, you can annotate key events with the SBPL rule or concept that makes them succeed:

  * Container path → container macros.
  * Home or external path → user-selected file entitlements plus extensions.
  * Print IPC → printing macro.
  * System fonts/dictionaries → read-only system resource rules.
  * Cloud paths → ubiquity-filter rules.

Crucially, this is not about building an exhaustive syscall catalog. It is about constructing a **small set of “trace vignettes”** that you can refer back to when explaining the sandbox to a human or to another tool. Once you have real captures in place, you can refine the mappings and tighten the story, but the structure laid out here—scenario, trace artefact, rule mapping—remains the same.
