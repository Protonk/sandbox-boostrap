# Global name

This note answers a host-scoped question about Mach `global-name` handling on `world_id sonoma-14.4.1-23E224-arm64-dyld-2c0602c5`. Specifically: when a sandbox profile grants permission for a controlled `global-name` AA, does a deterministically derived variant BB (for example AA with a suffix) relate to AA the same way for publish (`mach-register`) as it does for resolve (`mach-lookup`)?

It does so with three commensurable units: (1) a plan-based runtime bundle generated by `book.api.runtime` under `launchd_clean` provenance, (2) an intentionally asymmetric follow-up run that tries to stress the premise, and (3) a standalone in-process probe (user-supplied). Each unit includes a plain-language claim + setup and embeds the relevant code inline.

## Original question (exact)

> On this world_id, do the Mach operations that **publish** a global service name and **resolve** a global service name induce the **same equivalence relationship** over names—i.e., if a sandbox profile grants permission for a controlled `global-name` **AA**, is the allow/deny relationship between **AA** and a deterministically derived variant **BB** (e.g., AA with a runtime suffix) **the same** for publish as it is for resolve? Produce a minimal black-box proof (small program + output matrix) that answers this by composing outputs from `book/api` and `book/tools`. Record your proof in troubles/global_name.md.

Scope for this report (host-bound):
- world_id: `sonoma-14.4.1-23E224-arm64-dyld-2c0602c5`
- stage: `operation`
- ops: `mach-register` (publish), `mach-lookup` (resolve)
- filter: `global-name`

Notation:
- AA: the controlled `global-name` literal granted by the profile.
- BB: a deterministic variant of AA (either `AA + ".suffix"` or `AA + "." + getpid()`), checked under the same profile.

Equivalence relation (operational): for a fixed profile and a fixed operation, define `X ~ Y` iff the sandbox decision (allow vs deny) is the same for both names under that operation.

Answer (brief): in the "AA is allowed for the operation" regime, the observed AA/BB relationship matches across publish and resolve on this world: AA is allowed and BB is denied for both (for the AA→BB derivations tested below).

This note is a unitary account of:
- Unit 1: the plan-based runtime proof (repo-native harness + committed bundle).
- Unit 2: a follow-up asymmetric profile run intended to try to falsify the above (it does not apply the same premise).
- Unit 3: a standalone in-process probe (user-supplied) that tests a PID-derived BB with both ops allowed for AA.

### Interpreting `sandbox_check` output

`sandbox_check` returns:
- `rc == 0`: allow
- `rc == 1`: deny (not an error; `errno` is typically unchanged and often observed as 0)
- `rc == -1`: API error (then `errno` is meaningful)

So any "raw `(rc, errno)` matrix" must treat `errno` as evidence only when `rc == -1`.

## Unit 1: runtime plan proof (AA allowed for both ops)

### Claim

Original question (exact):

> On this world_id, do the Mach operations that **publish** a global service name and **resolve** a global service name induce the **same equivalence relationship** over names—i.e., if a sandbox profile grants permission for a controlled `global-name` **AA**, is the allow/deny relationship between **AA** and a deterministically derived variant **BB** (e.g., AA with a runtime suffix) **the same** for publish as it is for resolve? Produce a minimal black-box proof (small program + output matrix) that answers this by composing outputs from `book/api` and `book/tools`. Record your proof in troubles/global_name.md.

Plain language: under a deny-default profile that explicitly allows AA for both `mach-register` and `mach-lookup`, both operations allow AA and deny BB; i.e., they induce the same AA/BB equivalence for this AA→BB derivation.

claim:
  world_id: sonoma-14.4.1-23E224-arm64-dyld-2c0602c5
  status: ok
  stage: operation
  lane: scenario
  command: `PYTHONPATH=. python3 -m book.api.runtime run --plan book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/plan.json --channel launchd_clean --out book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/out`
  evidence:
    - book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/out/775d1303-74cf-403c-85a4-fd80cc02edde/artifact_index.json
    - book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/out/775d1303-74cf-403c-85a4-fd80cc02edde/runtime_results.json
  limits: `mach-register` is witnessed via `sandbox_check` (callout), not a `bootstrap_register*` syscall path

### Setup

Plain language setup: run a registered runtime plan under the `launchd_clean` channel so the worker begins unsandboxed, apply the SBPL profile at operation stage, then probe resolve with a real `bootstrap_look_up` call and probe publish with a `sandbox_check` decision query.

Rerun commands (build + preflight + run):

```sh
sh book/api/runtime/native/probes/build.sh
PYTHONPATH=. python3 book/tools/preflight/preflight.py scan book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/sb/mach_name_equivalence.sb
PYTHONPATH=. python3 -m book.api.runtime run --plan book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/plan.json --channel launchd_clean --out book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/out
```

- Probes/programs (built via `book/api/runtime/native/probes/build.sh`):
  - Resolve witness: `book/api/runtime/native/probes/sandbox_mach_probe.c` (`bootstrap_look_up`)
  - Publish decision witness: `book/api/runtime/native/probes/sandbox_check_self_apply_probe.c` (`sandbox_check`)
- Profile under test: `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/sb/mach_name_equivalence.sb`
- Applied runtime profile (from committed bundle; includes shim + key rules): `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/out/775d1303-74cf-403c-85a4-fd80cc02edde/runtime_profiles/mach_name_equivalence.mach-name-equivalence.runtime.sb`
- Apply-gate preflight: `PYTHONPATH=. python3 book/tools/preflight/preflight.py scan book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/sb/mach_name_equivalence.sb` → `classification=no_known_apply_gate_signature`
- Names:
  - AA = `com.apple.cfprefsd.agent`
  - BB = `com.apple.cfprefsd.agent.sandboxlore` (deterministic suffix variant)

SBPL profile source (`book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/sb/mach_name_equivalence.sb`):

```lisp
(version 1)
(deny default)

(allow mach-lookup (global-name "com.apple.cfprefsd.agent"))
(allow mach-register (global-name "com.apple.cfprefsd.agent"))
```

Applied runtime profile text (`book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/out/775d1303-74cf-403c-85a4-fd80cc02edde/runtime_profiles/mach_name_equivalence.mach-name-equivalence.runtime.sb`):

```lisp
(version 1)
(deny default)

(allow mach-lookup (global-name "com.apple.cfprefsd.agent"))
(allow mach-register (global-name "com.apple.cfprefsd.agent"))
(allow process-exec*)
(allow file-read* (subpath "/System"))
(allow file-read* (subpath "/usr"))
(allow file-read* (subpath "/bin"))
(allow file-read* (subpath "/sbin"))
(allow file-read* (subpath "/dev"))
(allow file-read-metadata (literal "/private"))
(allow file-read-metadata (literal "/private/tmp"))
(allow file-read-metadata (literal "/tmp"))
(allow mach-task-special-port-get)
(allow mach-bootstrap)
```

Resolve witness probe (`book/api/runtime/native/probes/sandbox_mach_probe.c`):

```c
/*
 * sandbox_mach_probe: apply an SBPL profile (from file) via sandbox_init, then
 * perform a single bootstrap_look_up for the given service name.
 *
 * Exits 0 on success, 1 on failure; prints {"kr":<code>} to stdout.
 *
 * Usage: sandbox_mach_probe <profile.sb> <service>
 */
#include "sandbox_profile.h"
#include "../tool_markers.h"
#include <mach/mach.h>
#include <servers/bootstrap.h>
#include <stdio.h>

static void usage(const char *prog) {
    fprintf(stderr, "Usage: %s <profile.sb> <service>\n", prog);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        usage(argv[0]);
        return 64; /* EX_USAGE */
    }

    const char *profile_path = argv[1];
    const char *service = argv[2];

    int apply_rc = sbl_apply_profile_from_path(profile_path);
    if (apply_rc != 0) {
        return apply_rc;
    }

    sbl_maybe_seatbelt_callout_from_env("pre_syscall");

    mach_port_t bootstrap = MACH_PORT_NULL;
    if (task_get_special_port(mach_task_self(), TASK_BOOTSTRAP_PORT, &bootstrap) != KERN_SUCCESS) {
        fprintf(stderr, "task_get_special_port failed\n");
        return 1;
    }

    mach_port_t port = MACH_PORT_NULL;
    kern_return_t kr = bootstrap_look_up(bootstrap, service, &port);
    if (kr == KERN_SUCCESS) {
        mach_port_deallocate(mach_task_self(), port);
    }
    const char *service_present = "null";
    if (kr == KERN_SUCCESS) {
        service_present = "true";
    } else if (kr == BOOTSTRAP_UNKNOWN_SERVICE) {
        service_present = "false";
    }
    printf(
        "SBL_PROBE_DETAILS {\"operation\":\"mach-lookup\",\"kr\":%d,\"service_present\":%s}\n",
        kr,
        service_present
    );
    printf("{\"kr\":%d}\n", kr);
    return kr == KERN_SUCCESS ? 0 : 1;
}
```

Publish decision probe (`book/api/runtime/native/probes/sandbox_check_self_apply_probe.c`):

```c
/*
 * sandbox_check_self_apply_probe: apply an SBPL profile (from file) via sandbox_init,
 * then evaluate a single seatbelt decision via sandbox_check.
 *
 * This mirrors the "self_apply" model used by sandbox_mach_probe so the probe
 * starts unsandboxed (avoids pre-exec staging-root file-read constraints) and
 * only enters the sandbox immediately before the check.
 *
 * Usage:
 *   sandbox_check_self_apply_probe <profile.sb> <operation> <filter_type> <argument> [filter_name]
 *
 * Exits 0 on allow, 1 on deny/error.
 */

#include "sandbox_profile.h"
#include "../tool_markers.h"
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int sandbox_check(pid_t pid, const char *operation, int type, ...);

/* Sandbox-check flags (bitwise OR with filter type). */
#define SANDBOX_CHECK_NO_REPORT 0x40000000

static void usage(const char *prog) {
    fprintf(stderr, "Usage: %s <profile.sb> <operation> <filter_type> <argument> [filter_name]\n", prog);
}

static void json_write_string(FILE *out, const char *s) {
    fputc('"', out);
    for (const unsigned char *p = (const unsigned char *)s; p && *p; p++) {
        switch (*p) {
        case '\\':
            fputs("\\\\", out);
            break;
        case '"':
            fputs("\\\"", out);
            break;
        case '\b':
            fputs("\\b", out);
            break;
        case '\f':
            fputs("\\f", out);
            break;
        case '\n':
            fputs("\\n", out);
            break;
        case '\r':
            fputs("\\r", out);
            break;
        case '\t':
            fputs("\\t", out);
            break;
        default:
            if (*p < 0x20) {
                fprintf(out, "\\u%04x", (unsigned int)*p);
            } else {
                fputc(*p, out);
            }
        }
    }
    fputc('"', out);
}

static void json_emit_kv_string(FILE *out, int *first, const char *k, const char *v) {
    if (!v) return;
    if (!*first) fputc(',', out);
    *first = 0;
    json_write_string(out, k);
    fputc(':', out);
    json_write_string(out, v);
}

static void json_emit_kv_int(FILE *out, int *first, const char *k, long v) {
    if (!*first) fputc(',', out);
    *first = 0;
    json_write_string(out, k);
    fprintf(out, ":%ld", v);
}

int main(int argc, char *argv[]) {
    if (argc < 5 || argc > 6) {
        usage(argv[0]);
        return 64; /* EX_USAGE */
    }

    const char *profile_path = argv[1];
    const char *operation = argv[2];
    const char *filter_str = argv[3];
    const char *argument = argv[4];
    const char *filter_name = argc == 6 ? argv[5] : NULL;

    char *end = NULL;
    long filter_type_long = strtol(filter_str, &end, 10);
    if (!end || *end != '\0' || filter_type_long < 0 || filter_type_long > 0x7fffffffL) {
        fprintf(stderr, "invalid filter_type: %s\n", filter_str);
        return 64; /* EX_USAGE */
    }
    int filter_type = (int)filter_type_long;

    int apply_rc = sbl_apply_profile_from_path(profile_path);
    if (apply_rc != 0) {
        return apply_rc;
    }

    /* Optional seatbelt callout markers (runner attribution aid). */
    sbl_maybe_seatbelt_callout_from_env("pre_syscall");

    errno = 0;
    int rc = 0;
    if (filter_type == 0) {
        rc = sandbox_check(getpid(), operation, filter_type);
    } else {
        int check_type = filter_type | SANDBOX_CHECK_NO_REPORT;
        rc = sandbox_check(getpid(), operation, check_type, argument);
    }
    int err = errno;

    const char *decision = (rc == 0) ? "allow" : "deny";

    int first = 1;
    fputs("SBL_PROBE_DETAILS ", stdout);
    fputc('{', stdout);
    json_emit_kv_string(stdout, &first, "operation", operation);
    json_emit_kv_int(stdout, &first, "filter_type", filter_type_long);
    json_emit_kv_string(stdout, &first, "argument", argument);
    if (filter_name && *filter_name) {
        json_emit_kv_string(stdout, &first, "filter_name", filter_name);
    }
    json_emit_kv_int(stdout, &first, "rc", rc);
    if (rc == -1) {
        json_emit_kv_int(stdout, &first, "errno", err);
        json_emit_kv_string(stdout, &first, "error", strerror(err));
    }
    json_emit_kv_string(stdout, &first, "decision", decision);
    fputs("}\n", stdout);
    fflush(stdout);

    return strcmp(decision, "allow") == 0 ? 0 : 1;
}
```

### Observed output matrix (from committed bundle)

| operation | AA | BB |
| --- | --- | --- |
| `mach-lookup` | allow | deny |
| `mach-register` | allow | deny |

Matrix extraction (from the cited `runtime_results.json`):

```sh
jq '.["mach-name-equivalence"].probes[] | {operation, name: .path, actual}' \
  book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/out/775d1303-74cf-403c-85a4-fd80cc02edde/runtime_results.json
```

### Interpretation

Within this profile family (deny-default + explicit allow AA for both ops), AA and BB do not collapse: AA is allowed, BB is denied, and the AA/BB relationship is the same across publish (`mach-register`) and resolve (`mach-lookup`) for this AA→BB derivation.

## Unit 2: asymmetric profile run (falsification attempt)

### Claim

Falsification prompt (exact):

> Can you try to falsify your equivalence claim by running an intentionally asymmetric sandbox profile that **allows only the Mach operation that publishes a name** for a chosen stem **AA** while **denying the operation that resolves a name** globally, then use a minimal program to print the raw `sandbox_check` return code and `errno` for **publish vs resolve** against **AA** and **BB** (where **BB = AA + getpid() suffix**), and report the resulting 2×2 matrix? Please place your work and the result in a new sub-section "### Falsification"

Plain language: apply an intentionally asymmetric profile that allows only publish (`mach-register`) for AA while denying resolve (`mach-lookup`) globally, then (in a single process) compute BB=`AA + "." + getpid()` and ask `sandbox_check` for the raw allow/deny decision on `{mach-register, mach-lookup} × {AA, BB}`.

claim:
  world_id: sonoma-14.4.1-23E224-arm64-dyld-2c0602c5
  status: ok
  stage: operation
  lane: scenario
  command: `book/api/runtime/native/probes/sandbox_check_self_apply_matrix_probe` (launched via launchd from a staged `/private/tmp` root; see the cited `job.plist`)
  evidence:
    - book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/sb/mach_name_falsification_publish_only.sb
    - book/api/runtime/native/probes/sandbox_check_self_apply_matrix_probe.c
    - book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/falsification/0b87ab83-6cff-4270-95c6-9f895f099096/stdout.txt
    - book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/falsification/0b87ab83-6cff-4270-95c6-9f895f099096/job.plist
  limits: this is a `sandbox_check` decision witness (not a `bootstrap_*` syscall path); and the asymmetric profile makes `mach-lookup` deny regardless of name, so it cannot discriminate name-matching semantics for resolve

### Setup

Plain language setup: because the interactive harness can already be sandbox-constrained, this probe was launched via a launchd job (plist recorded under the cited `falsification/.../job.plist`) so the worker begins unsandboxed, then enters the SBPL profile via `sandbox_init` before issuing `sandbox_check` queries.

Rerun commands (build + preflight):

```sh
sh book/api/runtime/native/probes/build.sh
PYTHONPATH=. python3 book/tools/preflight/preflight.py scan book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/sb/mach_name_falsification_publish_only.sb
```

Names:
- AA = `com.sandboxlore.falsify.globalname`
- BB = `AA + "." + getpid()` (captured in the probe's stdout)

SBPL profile (`book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/sb/mach_name_falsification_publish_only.sb`):

```lisp
(version 1)
(deny default)

(allow mach-register (global-name "com.sandboxlore.falsify.globalname"))
(deny mach-lookup)
```

Probe program (`book/api/runtime/native/probes/sandbox_check_self_apply_matrix_probe.c`):

```c
/*
 * sandbox_check_self_apply_matrix_probe: apply an SBPL profile (from file) via sandbox_init,
 * then evaluate multiple seatbelt decisions via sandbox_check in a single process.
 *
 * This probe is intended for "AA vs BB" questions where BB is derived from AA
 * using the current PID, so all checks must occur in the same process context.
 *
 * Usage:
 *   sandbox_check_self_apply_matrix_probe <profile.sb> <aa>
 *
 * Prints raw sandbox_check rc and errno for:
 *   - operation ∈ {mach-register, mach-lookup}
 *   - name ∈ {AA, BB} where BB = AA + "." + getpid()
 *
 * Exits 0 on successful execution (denies are expected).
 */

#include "sandbox_profile.h"
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

int sandbox_check(pid_t pid, const char *operation, int type, ...);

/* sandbox_check filter namespace: global-name is type 2 on this baseline. */
#define SANDBOX_CHECK_FILTER_GLOBAL_NAME 2

/* Sandbox-check flags (bitwise OR with filter type). */
#define SANDBOX_CHECK_NO_REPORT 0x40000000

static void usage(const char *prog) {
    fprintf(stderr, "Usage: %s <profile.sb> <aa>\n", prog);
}

typedef struct {
    int rc;
    int err;
} check_result_t;

static check_result_t check_global_name(const char *operation, const char *name) {
    errno = 0;
    int rc = sandbox_check(
        getpid(), operation, SANDBOX_CHECK_FILTER_GLOBAL_NAME | SANDBOX_CHECK_NO_REPORT, name);
    int err = errno;
    return (check_result_t){.rc = rc, .err = err};
}

static void print_cell(const char *operation, const char *label, const char *name, check_result_t result) {
    printf("%s %s name=%s rc=%d errno=%d\n", operation, label, name, result.rc, result.err);
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        usage(argv[0]);
        return 64; /* EX_USAGE */
    }

    const char *profile_path = argv[1];
    const char *aa = argv[2];

    pid_t pid = getpid();
    size_t bb_len = strlen(aa) + 1 + 32;
    char *bb = (char *)malloc(bb_len);
    if (!bb) {
        fprintf(stderr, "oom\n");
        return 70; /* EX_SOFTWARE */
    }
    snprintf(bb, bb_len, "%s.%d", aa, (int)pid);

    int apply_rc = sbl_apply_profile_from_path(profile_path);
    if (apply_rc != 0) {
        free(bb);
        return apply_rc;
    }

    printf("pid=%d\n", (int)pid);
    printf("AA=%s\n", aa);
    printf("BB=%s\n", bb);

    check_result_t reg_aa = check_global_name("mach-register", aa);
    check_result_t reg_bb = check_global_name("mach-register", bb);
    check_result_t lookup_aa = check_global_name("mach-lookup", aa);
    check_result_t lookup_bb = check_global_name("mach-lookup", bb);

    print_cell("mach-register", "AA", aa, reg_aa);
    print_cell("mach-register", "BB", bb, reg_bb);
    print_cell("mach-lookup", "AA", aa, lookup_aa);
    print_cell("mach-lookup", "BB", bb, lookup_bb);

    free(bb);
    return 0;
}
```

Observed raw output (`book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/falsification/0b87ab83-6cff-4270-95c6-9f895f099096/stdout.txt`):

```text
pid=6838
AA=com.sandboxlore.falsify.globalname
BB=com.sandboxlore.falsify.globalname.6838
mach-register AA name=com.sandboxlore.falsify.globalname rc=0 errno=0
mach-register BB name=com.sandboxlore.falsify.globalname.6838 rc=1 errno=0
mach-lookup AA name=com.sandboxlore.falsify.globalname rc=1 errno=0
mach-lookup BB name=com.sandboxlore.falsify.globalname.6838 rc=1 errno=0
```

Observed raw `sandbox_check` `(rc, errno)` matrix:

| operation | AA | BB |
| --- | --- | --- |
| `mach-register` | (0, 0) | (1, 0) |
| `mach-lookup` | (1, 0) | (1, 0) |

### Interpretation

This run demonstrates an *operation-level* asymmetry: if `mach-lookup` is denied globally, then resolve collapses AA and BB (both deny) while publish can still distinguish AA vs BB (allow vs deny) under an AA-only allowlist.

This does not falsify Unit 1's answer, because Unit 1 is about the AA→BB relationship in the "AA is allowed for the operation" regime for both ops; Unit 2 deliberately violates that premise by denying `mach-lookup` regardless of name.

## Unit 3: standalone in-process probe (user-supplied)

### Claim

Plain language: this user-supplied in-process program applies an in-memory SBPL string that denies `mach-lookup` and `mach-register`, then re-allows both ops only for the literal `global-name` `com.sblore.rendezvous.` and checks AA=`com.sblore.rendezvous.` vs BB=`com.sblore.rendezvous.<pid>`.

### Setup

Plain language setup: run the script; it writes a small C program to a temporary directory, compiles it, self-applies the in-memory SBPL profile via `sandbox_init_with_parameters`, then prints the raw `sandbox_check` decisions for AA vs BB across both operations.

Supplied script (verbatim):

```bash
tmpdir="$(mktemp -d)" && cat >"$tmpdir/mach_name_test.c" <<'C'
#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

enum sandbox_filter_type {
  SANDBOX_FILTER_NONE = 0,
  SANDBOX_FILTER_PATH = 1,
  SANDBOX_FILTER_GLOBAL_NAME = 2,
  SANDBOX_FILTER_LOCAL_NAME = 3,
  SANDBOX_FILTER_APPLEEVENT_DESTINATION = 4,
  SANDBOX_FILTER_RIGHT_NAME = 5,
  SANDBOX_FILTER_PREFERENCE_DOMAIN = 6,
  SANDBOX_FILTER_KEXT_BUNDLE_ID = 7,
  SANDBOX_FILTER_INFO_TYPE = 8,
  SANDBOX_FILTER_NOTIFICATION = 9
};

extern int sandbox_check(pid_t pid, const char *operation, enum sandbox_filter_type type, ...);
extern int sandbox_init_with_parameters(const char *profile, uint64_t flags,
                                       const char *const parameters[], char **errorbuf);
extern void sandbox_free_error(char *errorbuf);

static void do_check(const char *op, const char *name) {
  errno = 0;
  int rc = sandbox_check(getpid(), op, SANDBOX_FILTER_GLOBAL_NAME, name);
  int e = errno;
  printf("%s  name=\"%s\"  => rc=%d errno=%d (%s)\n", op, name, rc, e, strerror(e));
}

int main(void) {
  const char *profile =
    "(version 1)\n"
    "(allow default)\n"
    "(deny mach-lookup)\n"
    "(deny mach-register)\n"
    "(allow mach-register (global-name \"com.sblore.rendezvous.\"))\n"
    "(allow mach-lookup   (global-name \"com.sblore.rendezvous.\"))\n";

  const char *params[] = { NULL };
  char *err = NULL;

  int rc = sandbox_init_with_parameters(profile, /* SANDBOX_STRING */ 0x0000, params, &err);
  if (rc != 0) {
    fprintf(stderr, "sandbox_init_with_parameters failed rc=%d err=%s\n",
            rc, err ? err : "(null)");
    if (err) sandbox_free_error(err);
    return 2;
  }

  pid_t pid = getpid();
  char concrete[256];
  snprintf(concrete, sizeof(concrete), "com.sblore.rendezvous.%d", pid);

  printf("pid=%d\n", pid);
  do_check("mach-register", "com.sblore.rendezvous.");
  do_check("mach-register", concrete);
  do_check("mach-lookup",   "com.sblore.rendezvous.");
  do_check("mach-lookup",   concrete);

  return 0;
}
C
cc -Wall -Wextra -O2 "$tmpdir/mach_name_test.c" -o "$tmpdir/mach_name_test" && "$tmpdir/mach_name_test"
```

Observed output from running the supplied script on this host:

```text
pid=45895
mach-register  name="com.sblore.rendezvous."  => rc=0 errno=0 (Undefined error: 0)
mach-register  name="com.sblore.rendezvous.45895"  => rc=1 errno=0 (Undefined error: 0)
mach-lookup  name="com.sblore.rendezvous."  => rc=0 errno=0 (Undefined error: 0)
mach-lookup  name="com.sblore.rendezvous.45895"  => rc=1 errno=0 (Undefined error: 0)
```

### Interpretation

Unit 3 matches Unit 1's shape for a PID-derived BB with both ops allowed for AA: AA is allowed and BB is denied for both ops.

## Reconciliation (why these units do not conflict)

Plain language: Units 1 and 3 are answering the same question under the same premise ("AA is granted for the operation"). They agree: `global-name` behaves like an exact literal match for these AA→BB constructions, and the AA/BB relationship is the same for publish and resolve.

Unit 2 does not contradict that: it changes the premise by denying `mach-lookup` globally, which forces resolve to deny both AA and BB regardless of name. That demonstrates an operation-level asymmetry (as intended) but does not test whether resolve would distinguish AA vs BB when AA is actually granted for resolve.

## What could be wrong (failure modes to keep in mind)

- Unit 1 might overstate "publish" because it uses `sandbox_check` for `mach-register` (a decision witness) rather than a `bootstrap_register*` syscall path; a future witness could perform a real register under SBPL to confirm equivalence at syscall-adjacent level.
- Unit 2's matrix could be misread if treated as evidence about name-matching under resolve; it is primarily evidence about operation-level denial dominance (when an op is denied globally, name distinctions disappear).
- Unit 3 and Unit 2 depend on `sandbox_check`'s return-code semantics (deny is `rc==1` with `errno` typically 0); any run that produces `rc==-1` would require interpreting `errno` as an API error, not a policy deny.
- A common pitfall is mixing namespaces: PolicyGraph filter IDs (from `book/integration/carton/.../vocab/filters.json`, where `global-name` has id 5) are not the same as `sandbox_check` filter types (where `global-name` is type 2 on this baseline). Using the wrong number can yield an all-deny matrix that is a tooling error rather than a policy fact.
- Process provenance matters: these are decision-stage results only if the process started unsandboxed before applying the SBPL profile; Unit 1 uses `launchd_clean`, Unit 2 uses a launchd job plist, and Unit 3 applies in-process.

## Second opinion

Initial suspicions (before re-check):
- Potential conflation: Unit 1 uses `bootstrap_look_up` success/failure to infer allow/deny. That result can encode service existence (for example, `BOOTSTRAP_UNKNOWN_SERVICE`) rather than a sandbox policy denial, so the resolve-side AA/BB relationship may not be a `global-name` policy witness.
- Equivalence definition mismatch: the report defines equivalence in terms of a sandbox decision, but Unit 1’s resolve check observes an operational lookup result, not a `sandbox_check` decision; those are not the same kind of evidence.
- Top-line answer overreach: the brief answer states “AA allowed, BB denied for both,” but for resolve in Unit 1 that may mean “lookup succeeded/failed,” not “sandbox allowed/denied.” This should be qualified or re-verified with a decision witness.
- Implicit service-presence assumption: Unit 1’s resolve-side denial can be explained by absence of the BB service, independent of sandbox policy, which makes the equivalence claim fragile if service availability changes.

Verification run (launchd-clean, decision vs existence):

- Evidence bundle:
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/3d9f98fd-e035-4b29-a2f0-5ce3d1c80def/mach_name_second_opinion.c`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/3d9f98fd-e035-4b29-a2f0-5ce3d1c80def/equiv.stdout.txt`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/3d9f98fd-e035-4b29-a2f0-5ce3d1c80def/lookup.stdout.txt`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/3d9f98fd-e035-4b29-a2f0-5ce3d1c80def/equiv.plist`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/3d9f98fd-e035-4b29-a2f0-5ce3d1c80def/lookup.plist`

Script used (exact):

```sh
set -euo pipefail
RUN_ID="$(uuidgen | tr 'A-Z' 'a-z')"
STAGE="/private/tmp/sandbox_lore_second_opinion_${RUN_ID}"
OUT_DIR="book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/${RUN_ID}"
mkdir -p "$STAGE" "$OUT_DIR"
cat >"$STAGE/mach_name_second_opinion.c" <<'C'
#include <errno.h>
#include <mach/mach.h>
#include <servers/bootstrap.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

enum sandbox_filter_type {
  SANDBOX_FILTER_NONE = 0,
  SANDBOX_FILTER_PATH = 1,
  SANDBOX_FILTER_GLOBAL_NAME = 2,
  SANDBOX_FILTER_LOCAL_NAME = 3,
  SANDBOX_FILTER_APPLEEVENT_DESTINATION = 4,
  SANDBOX_FILTER_RIGHT_NAME = 5,
  SANDBOX_FILTER_PREFERENCE_DOMAIN = 6,
  SANDBOX_FILTER_KEXT_BUNDLE_ID = 7,
  SANDBOX_FILTER_INFO_TYPE = 8,
  SANDBOX_FILTER_NOTIFICATION = 9
};

extern int sandbox_check(pid_t pid, const char *operation, enum sandbox_filter_type type, ...);
extern int sandbox_init_with_parameters(const char *profile, uint64_t flags,
                                       const char *const parameters[], char **errorbuf);
extern void sandbox_free_error(char *errorbuf);

static int apply_profile(const char *profile) {
  const char *params[] = { NULL };
  char *err = NULL;
  int rc = sandbox_init_with_parameters(profile, /* SANDBOX_STRING */ 0x0000, params, &err);
  if (rc != 0) {
    fprintf(stderr, "sandbox_init_with_parameters failed rc=%d err=%s\n", rc, err ? err : "(null)");
    if (err) sandbox_free_error(err);
    return rc;
  }
  if (err) sandbox_free_error(err);
  return 0;
}

static void do_check(const char *op, const char *name) {
  errno = 0;
  int rc = sandbox_check(getpid(), op, SANDBOX_FILTER_GLOBAL_NAME, name);
  int e = errno;
  printf("sandbox_check op=%s name=\"%s\" rc=%d errno=%d (%s)\n", op, name, rc, e, strerror(e));
}

static void do_bootstrap_lookup(const char *name) {
  mach_port_t bootstrap = MACH_PORT_NULL;
  if (task_get_special_port(mach_task_self(), TASK_BOOTSTRAP_PORT, &bootstrap) != KERN_SUCCESS) {
    fprintf(stderr, "task_get_special_port failed\n");
    return;
  }
  mach_port_t port = MACH_PORT_NULL;
  kern_return_t kr = bootstrap_look_up(bootstrap, name, &port);
  if (kr == KERN_SUCCESS) {
    mach_port_deallocate(mach_task_self(), port);
  }
  const char *present = "null";
  if (kr == KERN_SUCCESS) {
    present = "true";
  } else if (kr == BOOTSTRAP_UNKNOWN_SERVICE) {
    present = "false";
  }
  printf("bootstrap_look_up name=\"%s\" kr=%d service_present=%s\n", name, kr, present);
}

static int run_equiv(void) {
  const char *aa = "com.sandboxlore.secondopinion.equiv";
  char bb[256];
  snprintf(bb, sizeof(bb), "%s.%d", aa, (int)getpid());

  char profile[512];
  snprintf(profile, sizeof(profile),
           "(version 1)\n"
           "(deny default)\n"
           "(allow mach-register (global-name \"%s\"))\n"
           "(allow mach-lookup (global-name \"%s\"))\n",
           aa, aa);

  int rc = apply_profile(profile);
  if (rc != 0) {
    return rc;
  }

  printf("mode=equiv pid=%d\n", (int)getpid());
  printf("AA=%s\n", aa);
  printf("BB=%s\n", bb);
  do_check("mach-register", aa);
  do_check("mach-register", bb);
  do_check("mach-lookup", aa);
  do_check("mach-lookup", bb);
  return 0;
}

static int run_lookup(void) {
  char aa[256];
  snprintf(aa, sizeof(aa), "com.sandboxlore.secondopinion.lookup.%d", (int)getpid());

  char profile[512];
  snprintf(profile, sizeof(profile),
           "(version 1)\n"
           "(deny default)\n"
           "(allow mach-lookup (global-name \"%s\"))\n",
           aa);

  int rc = apply_profile(profile);
  if (rc != 0) {
    return rc;
  }

  printf("mode=lookup pid=%d\n", (int)getpid());
  printf("AA=%s\n", aa);
  do_check("mach-lookup", aa);
  do_bootstrap_lookup(aa);
  return 0;
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    fprintf(stderr, "Usage: %s <equiv|lookup>\n", argv[0]);
    return 64;
  }
  if (strcmp(argv[1], "equiv") == 0) {
    return run_equiv();
  }
  if (strcmp(argv[1], "lookup") == 0) {
    return run_lookup();
  }
  fprintf(stderr, "unknown mode: %s\n", argv[1]);
  return 64;
}
C
cc -Wall -Wextra -O2 "$STAGE/mach_name_second_opinion.c" -o "$STAGE/mach_name_second_opinion"

run_job() {
  local mode="$1"
  local label="sandbox-lore.second-opinion.${RUN_ID}.${mode}"
  local plist="$STAGE/${label}.plist"
  local out="$STAGE/${mode}.stdout.txt"
  local err="$STAGE/${mode}.stderr.txt"
  cat >"$plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key><string>${label}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${STAGE}/mach_name_second_opinion</string>
    <string>${mode}</string>
  </array>
  <key>RunAtLoad</key><true/>
  <key>WorkingDirectory</key><string>${STAGE}</string>
  <key>StandardOutPath</key><string>${out}</string>
  <key>StandardErrorPath</key><string>${err}</string>
</dict>
</plist>
EOF
  plutil -lint "$plist" >/dev/null
  local uid_num
  uid_num="$(id -u)"
  launchctl bootstrap "gui/${uid_num}" "$plist"
  for _ in $(seq 1 40); do
    if [ -s "$out" ] || [ -s "$err" ]; then
      break
    fi
    sleep 0.25
  done
  launchctl bootout "gui/${uid_num}" "$plist" >/dev/null 2>&1 || true
  cp "$plist" "$OUT_DIR/${mode}.plist"
  cp "$out" "$OUT_DIR/${mode}.stdout.txt" || true
  cp "$err" "$OUT_DIR/${mode}.stderr.txt" || true
}

run_job equiv
run_job lookup

cp "$STAGE/mach_name_second_opinion.c" "$OUT_DIR/mach_name_second_opinion.c"
printf "%s\n" "$OUT_DIR"
```

Observed output (equiv decision witness):

```text
mode=equiv pid=78837
AA=com.sandboxlore.secondopinion.equiv
BB=com.sandboxlore.secondopinion.equiv.78837
sandbox_check op=mach-register name="com.sandboxlore.secondopinion.equiv" rc=0 errno=0 (Undefined error: 0)
sandbox_check op=mach-register name="com.sandboxlore.secondopinion.equiv.78837" rc=1 errno=0 (Undefined error: 0)
sandbox_check op=mach-lookup name="com.sandboxlore.secondopinion.equiv" rc=0 errno=0 (Undefined error: 0)
sandbox_check op=mach-lookup name="com.sandboxlore.secondopinion.equiv.78837" rc=1 errno=0 (Undefined error: 0)
```

Observed output (lookup existence confound):

```text
mode=lookup pid=78855
AA=com.sandboxlore.secondopinion.lookup.78855
sandbox_check op=mach-lookup name="com.sandboxlore.secondopinion.lookup.78855" rc=0 errno=0 (Undefined error: 0)
bootstrap_look_up name="com.sandboxlore.secondopinion.lookup.78855" kr=1102 service_present=false
```

Reasoning:
- The equiv run uses `sandbox_check` for both ops under the same AA-allow profile; it shows AA allowed and BB denied for both `mach-register` and `mach-lookup`. That is the decision-level equivalence the original question asks about.
- The lookup run shows `sandbox_check` allowing a unique AA for resolve while `bootstrap_look_up` returns `BOOTSTRAP_UNKNOWN_SERVICE` (`kr=1102`) because the service is not registered. This demonstrates that a `bootstrap_look_up` failure can reflect service absence rather than sandbox policy, confirming the conflation risk in Unit 1’s resolve-side witness.

Syscall-level publish witness (bootstrap_register):

- Evidence bundle:
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/67efb8e1-387e-4c0d-99b5-954b8898685d/mach_name_register_witness.c`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/67efb8e1-387e-4c0d-99b5-954b8898685d/nosandbox.stdout.txt`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/67efb8e1-387e-4c0d-99b5-954b8898685d/sandbox.stdout.txt`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/67efb8e1-387e-4c0d-99b5-954b8898685d/nosandbox.plist`
  - `book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/67efb8e1-387e-4c0d-99b5-954b8898685d/sandbox.plist`

Script used (exact):

```sh
set -euo pipefail
RUN_ID="67efb8e1-387e-4c0d-99b5-954b8898685d"
STAGE="/private/tmp/sandbox_lore_register_witness_${RUN_ID}"
OUT_DIR="book/evidence/experiments/runtime-final-final/suites/mach-name-equivalence/second_opinion/${RUN_ID}"
mkdir -p "$STAGE" "$OUT_DIR"
cat >"$STAGE/mach_name_register_witness.c" <<'C'
#include <errno.h>
#include <mach/mach.h>
#include <servers/bootstrap.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

extern int sandbox_init_with_parameters(const char *profile, uint64_t flags,
                                       const char *const parameters[], char **errorbuf);
extern void sandbox_free_error(char *errorbuf);

static int apply_profile_for(const char *aa) {
  char profile[512];
  snprintf(profile, sizeof(profile),
           "(version 1)\n"
           "(deny default)\n"
           "(allow mach-bootstrap)\n"
           "(allow mach-task-special-port-get)\n"
           "(allow mach-register (global-name \"%s\"))\n",
           aa);

  const char *params[] = { NULL };
  char *err = NULL;
  int rc = sandbox_init_with_parameters(profile, /* SANDBOX_STRING */ 0x0000, params, &err);
  if (rc != 0) {
    fprintf(stderr, "sandbox_init_with_parameters failed rc=%d err=%s\n",
            rc, err ? err : "(null)");
    if (err) sandbox_free_error(err);
    return rc;
  }
  if (err) sandbox_free_error(err);
  return 0;
}

static void print_kr(const char *label, kern_return_t kr) {
  const char *msg = bootstrap_strerror(kr);
  printf("%s kr=%d (%s)\n", label, kr, msg ? msg : "(null)");
}

static void do_register(const char *name) {
  name_t service_name = {0};
  if (strlen(name) >= sizeof(service_name)) {
    fprintf(stderr, "name too long: %s\n", name);
    return;
  }
  snprintf(service_name, sizeof(service_name), "%s", name);

  mach_port_t port = MACH_PORT_NULL;
  kern_return_t kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
  if (kr != KERN_SUCCESS) {
    print_kr("mach_port_allocate", kr);
    return;
  }

  kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
  if (kr != KERN_SUCCESS) {
    print_kr("mach_port_insert_right", kr);
    mach_port_deallocate(mach_task_self(), port);
    return;
  }

  kr = bootstrap_register(bootstrap_port, service_name, port);
  printf("bootstrap_register name=\"%s\" ", name);
  print_kr("", kr);

  mach_port_deallocate(mach_task_self(), port);
}

static void usage(const char *prog) {
  fprintf(stderr, "Usage: %s <sandbox|nosandbox>\n", prog);
}

int main(int argc, char *argv[]) {
  if (argc != 2) {
    usage(argv[0]);
    return 64;
  }

  const char *mode = argv[1];
  const char *aa = "com.sandboxlore.registerwitness";
  char bb[256];
  snprintf(bb, sizeof(bb), "%s.%d", aa, (int)getpid());

  if (strcmp(mode, "sandbox") == 0) {
    int rc = apply_profile_for(aa);
    if (rc != 0) {
      return rc;
    }
  } else if (strcmp(mode, "nosandbox") != 0) {
    usage(argv[0]);
    return 64;
  }

  printf("mode=%s pid=%d\n", mode, (int)getpid());
  printf("AA=%s\n", aa);
  printf("BB=%s\n", bb);

  do_register(aa);
  do_register(bb);

  return 0;
}
C
cc -Wall -Wextra -O2 "$STAGE/mach_name_register_witness.c" -o "$STAGE/mach_name_register_witness" -lsandbox

run_job() {
  local mode="$1"
  local label="sandbox-lore.register-witness.${RUN_ID}.${mode}"
  local plist="$STAGE/${label}.plist"
  local out="$STAGE/${mode}.stdout.txt"
  local err="$STAGE/${mode}.stderr.txt"
  cat >"$plist" <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>Label</key><string>${label}</string>
  <key>ProgramArguments</key>
  <array>
    <string>${STAGE}/mach_name_register_witness</string>
    <string>${mode}</string>
  </array>
  <key>RunAtLoad</key><true/>
  <key>WorkingDirectory</key><string>${STAGE}</string>
  <key>StandardOutPath</key><string>${out}</string>
  <key>StandardErrorPath</key><string>${err}</string>
</dict>
</plist>
EOF
  plutil -lint "$plist" >/dev/null
  local uid_num
  uid_num="$(id -u)"
  launchctl bootstrap "gui/${uid_num}" "$plist"
  for _ in $(seq 1 40); do
    if [ -s "$out" ] || [ -s "$err" ]; then
      break
    fi
    sleep 0.25
  done
  launchctl bootout "gui/${uid_num}" "$plist" >/dev/null 2>&1 || true
  cp "$plist" "$OUT_DIR/${mode}.plist"
  cp "$out" "$OUT_DIR/${mode}.stdout.txt" || true
  cp "$err" "$OUT_DIR/${mode}.stderr.txt" || true
}

run_job nosandbox
run_job sandbox

cp "$STAGE/mach_name_register_witness.c" "$OUT_DIR/mach_name_register_witness.c"
```

Observed output (nosandbox control):

```text
mode=nosandbox pid=83716
AA=com.sandboxlore.registerwitness
BB=com.sandboxlore.registerwitness.83716
bootstrap_register name="com.sandboxlore.registerwitness"  kr=0 (Success)
bootstrap_register name="com.sandboxlore.registerwitness.83716"  kr=0 (Success)
```

Observed output (sandbox, AA allowed for publish):

```text
mode=sandbox pid=83729
AA=com.sandboxlore.registerwitness
BB=com.sandboxlore.registerwitness.83729
bootstrap_register name="com.sandboxlore.registerwitness"  kr=0 (Success)
bootstrap_register name="com.sandboxlore.registerwitness.83729"  kr=1100 (Permission denied)
```

Reasoning:
- The nosandbox control shows `bootstrap_register` succeeds for both AA and BB in this process context, so the syscall path itself is viable here.
- Under the deny-default SBPL that allows only `mach-register` for AA, the syscall-level publish succeeds for AA and fails for BB (`BOOTSTRAP_NOT_PRIVILEGED`), matching the decision-level AA/BB split. This provides a publish witness that does not rely on `sandbox_check`.

## Status

- ok
