### 2.2 Profiles, containers, and entitlements in practice

The TextEdit example makes the abstract “policy stack” from the orientation concrete. A running process is constrained by three things at once:

1. A generic app sandbox profile (`application.sb`), written in SBPL.
2. A set of parameters that specialize that profile for a particular app (bundle ids, container paths, dyld paths).
3. A small set of entitlements that toggle profile fragments on or off.

For TextEdit, those three layers combine into a single effective profile, captured in `textedit-specialized.sb`. This section walks through how that profile is structured, how the container fits into it, and how specific entitlements light up pieces of the SBPL.

#### 2.2.1 The container as the primary write zone

The starting point is the container root:

> `~/Library/Containers/com.apple.TextEdit/Data`

The specialized profile treats everything under this path as TextEdit’s primary read/write zone. The `appsandbox-container-common` and `appsandbox-container-macos` macros are active, and they wire up a cluster of parameters:

* `application_container` / `application_container_id`
* `application_darwin_user_dir`
* `application_darwin_cache_dir`
* `application_darwin_temp_dir`

These parameters point at TextEdit’s “user”, “cache”, and “temporary” directories inside the container. The corresponding SBPL rules:

* Allow read/write directory contents in these areas.
* Permit `file-mount` / `file-unmount` there.
* Route the sandbox’s notion of “tmpdir” through a container-local path.

The net effect is that TextEdit can treat the container much like a private home directory:

* It can create and remove files and directories.
* It can use scratch space and caches.
* It can mount and unmount temporary volumes or special filesystem views in its own space.

Outside the container, the profile becomes conservative. System paths such as `/System`, `/bin`, `/usr/bin`, `/usr/sbin` are allowed for `file-read*` and `process-exec` but not for write operations. `/Library` is largely read-only except for small, controlled regions (e.g., some keychain paths, certain audio presets). The structural invariant is simple:

* **Default writes live in the container; the rest of the system is effectively read-only.**

This does not mean TextEdit cannot ever touch external documents or shared state; it means that doing so always involves another mechanism (entitlements and extensions) rather than broad path-based write rules.

#### 2.2.2 Bundle and scripts as a controlled boundary

The profile also treats the application bundle and scripts directories as first-class objects, but in a tightly constrained way.

Wherever `application_bundle` is set, the SBPL includes rules like:

* Allow read-directory-contents for the bundle.
* Allow `process-exec` for binaries under the bundle path.

Similarly, for the scripts directory:

* Paths under `~/Library/Application Scripts/com.apple.TextEdit` are allowed for read-only access and `process-exec`.

These areas form a second kind of “trusted zone” distinct from the container:

* The bundle is where TextEdit’s own executable code and resources live.
* The application scripts directory is where extension scripts or helpers reside, possibly shared with other components.

In both cases, the profile emphasizes **readability and executability**, not general write capability. TextEdit can execute its own binaries and helper scripts and read their resources, but these paths do not become general-purpose dump grounds for user data or logs. Writes remain anchored to the container’s Data, cache, and temp directories.

This reinforces a separation:

* **Code and fixed assets**: bundle and script directories, read/exec.
* **Mutable data**: container Data, caches, temp, read/write.

#### 2.2.3 Parameters as the glue between profile and filesystem

One of the more useful lessons from TextEdit’s profile is how heavily `application.sb` relies on parameters to avoid hard-coding paths. The profile repeatedly uses expressions like:

* `(param "application_bundle_id")`
* `(param "application_container_id")`
* `(param "application_bundle")`
* `(param "application_dyld_paths")`
* `(param "application_darwin_user_dir")`, `cache_dir`, `temp_dir`

For TextEdit, those parameters conceptually resolve to:

* `application_bundle_id = "com.apple.TextEdit"`
* `application_container_id = "com.apple.TextEdit"`
* `application_bundle` = `/System/Applications/TextEdit.app` (or equivalent)
* `application_container` = `~/Library/Containers/com.apple.TextEdit/Data`
* `application_dyld_paths` = a colon-separated list of relevant library search paths

The specialized profile preserves these as `(param ...)` calls rather than baking in concrete strings. That makes the file portable, but more importantly, it shows how a single template can serve thousands of apps:

* The same `(when (param "application_bundle")) ...` block supports any app whose bundle path is known.
* The same `appsandbox-container-macos` macro can be reused as long as `application_darwin_*` parameters are filled in.

For TextEdit, these parameterized rules connect directly to concrete capabilities:

* Parameterized dyld path handling allows `file-read*` and `process-exec` for dynamic libraries under the configured search paths, and issues extensions for those paths.
* Parameterized container paths define where autosave, caches, and temp data can be written.
* Parameterized bundle identifiers are used to construct paths under `/Library/Managed Preferences` and App Store support directories, so TextEdit can read its managed preferences and any App Store content specific to its bundle id.

The key conceptual point is that the **profile is not written “for TextEdit”**; it is written “for any sandboxed app with these parameters.” The specialization step simply plugs TextEdit’s identifiers and paths into those slots.

#### 2.2.4 Entitlements as switches for structural features

The entitlements plist then acts as a set of switches deciding which parts of `application.sb` are live for TextEdit.

Some examples:

* `com.apple.security.app-sandbox = true`
  This is the fundamental switch: it selects `application.sb` as the base profile and enables the whole app sandbox machinery, including container macros and parameterized path rules. Without it, TextEdit would not run under `application.sb` at all.

* `com.apple.developer.ubiquity-container-identifiers = ["com.apple.TextEdit"]`
  This entitlement feeds directly into a `sandbox-array-entitlement` block. For each id in the array:

  * The profile allows `file-link` for `ubiquity-filter id`.
  * It enables `read-write-and-issue-extensions` within that filter.

  In specialized form, this becomes a pair of rules targeting TextEdit’s iCloud container:

  * “You may create links and read/write here.”
  * “You may issue extensions for these paths.”

  Entitlement → filtered path rules → concrete cloud storage behaviour.

* User-selected file entitlements (`com.apple.security.files.user-selected.read-write`, `com.apple.security.files.user-selected.executable`)
  These do not create big path-based allows by themselves. Instead, they activate blocks that:

  * Permit mach-lookup to the scoped bookmarks agent.
  * Allow issuance of sandbox extensions for user-selected paths.
  * Authorize read, write, and exec on paths that carry those extensions.

  The structural effect is that **outside-container access is extension-driven** rather than path-driven. The entitlements turn on the plumbing; the extensions carry the specific paths.

* Printing and other capabilities
  `com.apple.security.print` toggles inclusion of the `(printing)` macro, which brings in an entire set of IPC and path rules for the printing subsystem. Several other entitlements (e.g., camera, network client/server) are absent for TextEdit, so their corresponding blocks simply do not appear in the specialized profile.

Taken together, the mapping is clear:

* **Entitlements do not replace the profile**; they **select and tune pieces of it**.
* Each entitlement either:

  * Activates a well-defined macro (printing, camera, network).
  * Provides values to array entitlements (ubiquity, application groups).
  * Enables extension-oriented flows (user-selected files, bookmarks).

#### 2.2.5 Flows and invariants

When you combine the container structure, parameters, and entitlements, a small set of invariants emerges for TextEdit:

* Default writes stay inside the container:

  * Data, caches, temp, and related `application_darwin_*` directories are always writable and mountable.
  * This is true regardless of which external file entitlements are present.

* System resources remain read-only:

  * `/System`, `/bin`, `/usr/bin`, `/usr/sbin` are available for reading and execution, not for writing.
  * `/Library` is mostly read-only; specific subtrees are carved out for preferences or assets, but not for general data dumping.

* External documents are mediated:

  * Any access to files outside the container (Documents, Downloads, external volumes) hinges on user-selected file entitlements and the corresponding extension machinery.
  * The profile expects an extension to be in place before `file-read*`/`file-write*`/`process-exec` is allowed on those paths.

* Cloud storage is scoped:

  * iCloud access flows through a `ubiquity-filter` for `"com.apple.TextEdit"`.
  * TextEdit’s profile does not grant carte blanche access to other ubiquity containers.

* Code locations are special but controlled:

  * Bundle and scripts directories are readable and executable, but not writable by default.
  * They function as trusted code/asset zones, not as general-purpose storage.

The “profile + container + entitlements” story for TextEdit is therefore not a loose set of rules but a coherent model:

* A generic template (`application.sb`) defines the shape of an app’s sandbox.
* Parameters pin that template to TextEdit’s bundle id and filesystem locations.
* Entitlements selectively activate features that extend the container outward in narrow, structured ways (user-selected files, iCloud, printing).

Later sections can trace individual operations—opening a document, autosaving, printing, syncing—to these structural elements. Here the main job is to see how those elements interlock: the container as the center, parameters as the glue, and entitlements as the switches that illuminate specific paths out to the rest of the system.
