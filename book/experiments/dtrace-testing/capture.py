"""
Run a PID-scoped DTrace capture for EntitlementJail and emit JSONL.
"""

from __future__ import annotations

import argparse
import json
import pathlib
import signal
import subprocess
import time
from typing import Optional

from book.api import path_utils
from book.api.profile.identity import baseline_world_id

DTRACE_BIN = "/usr/sbin/dtrace"


def render_dtrace_script(*, phase: str) -> str:
    lines = [
        "#pragma D option quiet",
        "#pragma D option bufsize=16m",
        "#pragma D option dynvarsize=16m",
        "#pragma D option strsize=2048",
        f'inline string PHASE = "{phase}";',
        "inline int ERR_EPERM = 1;",
        "inline int ERR_EACCES = 13;",
        "",
        "/* open/open_nocancel */",
        "syscall::open:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = (int)arg1;",
        "    self->mode = (int)arg2;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::open:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "syscall::open_nocancel:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = (int)arg1;",
        "    self->mode = (int)arg2;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::open_nocancel:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* openat/openat_nocancel */",
        "syscall::openat*:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg1);",
        "    self->path2 = \"\";",
        "    self->flags = (int)arg2;",
        "    self->mode = (int)arg3;",
        "    self->dirfd = (int)arg0;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::openat*:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* stat/lstat */",
        "syscall::stat:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::stat:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "syscall::lstat:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::lstat:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "syscall::stat64:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::stat64:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "syscall::lstat64:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::lstat64:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* access */",
        "syscall::access:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = (int)arg1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::access:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* unlink/unlinkat */",
        "syscall::unlink:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::unlink:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "syscall::unlinkat:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg1);",
        "    self->path2 = \"\";",
        "    self->flags = (int)arg2;",
        "    self->mode = -1;",
        "    self->dirfd = (int)arg0;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::unlinkat:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* rename/renameat */",
        "syscall::rename:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = copyinstr(arg1);",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::rename:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "syscall::renameat:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg1);",
        "    self->path2 = copyinstr(arg3);",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = (int)arg0;",
        "    self->newdirfd = (int)arg2;",
        "}",
        "syscall::renameat:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* mkdir/mkdirat */",
        "syscall::mkdir:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = (int)arg1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::mkdir:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "syscall::mkdirat:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg1);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = (int)arg2;",
        "    self->dirfd = (int)arg0;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::mkdirat:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* rmdir */",
        "syscall::rmdir:entry",
        "/pid == $target/",
        "{",
        "    self->sys = probefunc;",
        "    self->path = copyinstr(arg0);",
        "    self->path2 = \"\";",
        "    self->flags = -1;",
        "    self->mode = -1;",
        "    self->dirfd = -1;",
        "    self->newdirfd = -1;",
        "}",
        "syscall::rmdir:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"syscall\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"path\\\":\\\"%s\\\",\\\"path2\\\":\\\"%s\\\",\\\"flags\\\":%d,\\\"mode\\\":%d,\\\"dirfd\\\":%d,\\\"newdirfd\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sys, self->path, self->path2, self->flags, self->mode, self->dirfd, self->newdirfd, (int)arg0, this->err);",
        "    }",
        "    self->sys = 0;",
        "    self->path = 0;",
        "    self->path2 = 0;",
        "    self->flags = 0;",
        "    self->mode = 0;",
        "    self->dirfd = 0;",
        "    self->newdirfd = 0;",
        "}",
        "",
        "/* sandbox_check */",
        "pid$target::sandbox_check:entry",
        "/pid == $target/",
        "{",
        "    self->sb_name = probefunc;",
        "    self->sb_op = \"\";",
        "    if (arg1 != 0) {",
        "        self->sb_op = copyinstr(arg1);",
        "    }",
        "    self->sb_type = (int)arg2;",
        "}",
        "pid$target::sandbox_check:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"sandbox_api\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"op\\\":\\\"%s\\\",\\\"type\\\":%d,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sb_name, self->sb_op, self->sb_type, (int)arg0, this->err);",
        "    }",
        "    self->sb_name = 0;",
        "    self->sb_op = 0;",
        "    self->sb_type = 0;",
        "}",
        "",
        "/* sandbox_init */",
        "pid$target::sandbox_init:entry",
        "/pid == $target/",
        "{",
        "    self->sb_name = probefunc;",
        "    self->sb_profile = \"\";",
        "    if (arg0 != 0) {",
        "        self->sb_profile = copyinstr(arg0);",
        "    }",
        "    self->sb_flags = (unsigned long long)arg1;",
        "}",
        "pid$target::sandbox_init:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"sandbox_api\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"profile\\\":\\\"%s\\\",\\\"flags\\\":%llu,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sb_name, self->sb_profile, self->sb_flags, (int)arg0, this->err);",
        "    }",
        "    self->sb_name = 0;",
        "    self->sb_profile = 0;",
        "    self->sb_flags = 0;",
        "}",
        "",
        "/* sandbox_apply */",
        "pid$target::sandbox_apply:entry",
        "/pid == $target/",
        "{",
        "    self->sb_name = probefunc;",
        "    self->sb_policy = (unsigned long long)arg0;",
        "}",
        "pid$target::sandbox_apply:return",
        "/pid == $target/",
        "{",
        "    this->err = errno;",
        "    if (this->err == ERR_EPERM || this->err == ERR_EACCES) {",
        "        printf(\"{\\\"phase\\\":\\\"%s\\\",\\\"kind\\\":\\\"sandbox_api\\\",\\\"ts_ns\\\":%llu,\\\"pid\\\":%d,\\\"execname\\\":\\\"%s\\\",\\\"name\\\":\\\"%s\\\",\\\"policy_ptr\\\":%llu,\\\"ret\\\":%d,\\\"errno\\\":%d}\\n\",\n",
        "            PHASE, walltimestamp, pid, execname, self->sb_name, self->sb_policy, (int)arg0, this->err);",
        "    }",
        "    self->sb_name = 0;",
        "    self->sb_policy = 0;",
        "}",
    ]
    return "\n".join(lines) + "\n"


def run_dtrace(
    *,
    raw_out: pathlib.Path,
    script_out: pathlib.Path,
    stderr_out: pathlib.Path,
    target_pid: int,
    duration_s: float,
    phase: str,
) -> int:
    script_text = render_dtrace_script(phase=phase)
    script_out.parent.mkdir(parents=True, exist_ok=True)
    script_out.write_text(script_text)

    cmd = [DTRACE_BIN, "-q", "-s", str(script_out), "-p", str(target_pid)]
    raw_out.parent.mkdir(parents=True, exist_ok=True)
    with raw_out.open("w") as stdout, stderr_out.open("w") as stderr:
        proc = subprocess.Popen(cmd, stdout=stdout, stderr=stderr)
        time.sleep(duration_s)
        proc.send_signal(signal.SIGINT)
        try:
            return proc.wait(timeout=5)
        except subprocess.TimeoutExpired:
            proc.terminate()
            return proc.wait(timeout=5)


def write_meta(
    *,
    meta_out: pathlib.Path,
    repo_root: pathlib.Path,
    phase: str,
    target_pid: int,
    raw_out: pathlib.Path,
    script_out: pathlib.Path,
    stderr_out: pathlib.Path,
    duration_s: float,
    exit_code: Optional[int],
) -> None:
    meta = {
        "world_id": baseline_world_id(repo_root),
        "phase": phase,
        "target_pid": target_pid,
        "duration_s": duration_s,
        "raw_path": path_utils.to_repo_relative(raw_out, repo_root),
        "script_path": path_utils.to_repo_relative(script_out, repo_root),
        "stderr_path": path_utils.to_repo_relative(stderr_out, repo_root),
        "command": path_utils.relativize_command([DTRACE_BIN, "-q", "-s", str(script_out), "-p", str(target_pid)], repo_root),
        "exit_code": exit_code,
    }
    meta_out.parent.mkdir(parents=True, exist_ok=True)
    meta_out.write_text(json.dumps(meta, indent=2, sort_keys=True))


def main() -> int:
    parser = argparse.ArgumentParser(description="Run DTrace capture for EntitlementJail PID.")
    parser.add_argument("--target-pid", type=int, required=True, help="PID to attach with -p.")
    parser.add_argument("--phase", required=True, help="Phase label (smoke, idle, interaction).")
    parser.add_argument("--duration", type=float, default=10.0, help="Capture duration in seconds.")
    parser.add_argument(
        "--raw-out",
        default=None,
        help="Path to write raw JSONL (defaults to out/raw/<phase>.jsonl).",
    )
    parser.add_argument(
        "--meta-out",
        default=None,
        help="Path to write meta JSON (defaults to out/meta/<phase>.json).",
    )
    args = parser.parse_args()

    repo_root = path_utils.find_repo_root(pathlib.Path(__file__))
    phase = args.phase
    raw_out = pathlib.Path(args.raw_out) if args.raw_out else pathlib.Path(
        f"book/experiments/dtrace-testing/out/raw/{phase}.jsonl"
    )
    meta_out = pathlib.Path(args.meta_out) if args.meta_out else pathlib.Path(
        f"book/experiments/dtrace-testing/out/meta/{phase}.json"
    )
    raw_out = path_utils.ensure_absolute(raw_out, repo_root)
    meta_out = path_utils.ensure_absolute(meta_out, repo_root)
    script_out = path_utils.ensure_absolute(
        f"book/experiments/dtrace-testing/out/meta/dtrace_{phase}.d",
        repo_root,
    )
    stderr_out = path_utils.ensure_absolute(
        f"book/experiments/dtrace-testing/out/meta/dtrace_{phase}.stderr",
        repo_root,
    )

    exit_code = run_dtrace(
        raw_out=raw_out,
        script_out=script_out,
        stderr_out=stderr_out,
        target_pid=args.target_pid,
        duration_s=args.duration,
        phase=phase,
    )

    write_meta(
        meta_out=meta_out,
        repo_root=repo_root,
        phase=phase,
        target_pid=args.target_pid,
        raw_out=raw_out,
        script_out=script_out,
        stderr_out=stderr_out,
        duration_s=args.duration,
        exit_code=exit_code,
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
