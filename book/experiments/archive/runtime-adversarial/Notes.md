# Notes

- Re-ran `python run_adversarial.py` after adding file-write* rules to structural/path_edges SBPL and adding a network-outbound family (`net_outbound_allow`, `net_outbound_deny`).
  - Filesystem/mach families remain as before: struct_flat vs struct_nested match on read/write; path_edges shows `/tmp`â†’`/private/tmp` EPERM mismatches; mach literal/regex variants match.
  - Network: initial ping/TCP attempts mismatched on allow due to client startup constraints. Swapped the client to `/usr/bin/nc` (no Python in the sandbox) with explicit startup shims; TCP loopback now succeeds in allow profile and denies in deny profile.
- Refreshed `python run_adversarial.py` during the runtime cutover: all adversarial probes now fail at apply (`sandbox_init` EPERM), so `out/runtime_results.json` + `out/mismatch_summary.json` reflect apply-gate blocks and the per-op summary reports only blocked counts. Treat earlier allow/deny outcomes as historical until apply succeeds again.
- Re-ran `python run_adversarial.py` after the host was made more permissive (`--yolo`): apply-stage EPERM cleared across adversarial families; only the expected `path_edges` mismatches remain and network/mach families match expectations again.
- Added `path_alias` and `flow_divert_require_all_tcp` profiles, then reran `python3 run_adversarial.py`; apply-stage EPERM persisted (`sandbox_init` failure) across all adversarial probes, so the latest outputs are blocked/partial and should be treated as attempted-only evidence.
- Added apply-only preflight capture (`out/apply_preflight.json`) with runner entitlements + parent-chain context; apply-stage EPERM is now recorded as blocked evidence separate from probe outcomes.
- Switched file-read*/file-write* probes to use `file_probe` under `sandbox_runner` so each scenario applies exactly once inside a fresh worker; added unsandboxed F_GETPATH observations to `runtime_results.json` to preserve path canonicalization evidence even when apply-gated.
- Added historical runtime event retention (`out/historical_runtime_events.json`) to keep last decision-stage witnesses when new runs are apply-gated.
- Added launchctl procinfo + libproc parent-chain attribution to `out/apply_preflight.json` and a runtime clean-channel run path that requires successful apply preflight.
- Latest apply preflight shows `launchctl procinfo` requires root and `log show` is blocked (`Cannot run while sandboxed`); parent-chain attribution points at the Codex launcher path.
- Clean-channel run initially failed with `Operation not permitted` opening `run_adversarial.py` from a Desktop path; now stage the repo into `/private/tmp` via the runtime clean channel and sync outputs back.
- Launchd-staged run succeeded: `out/runtime_results.json` now carries decision-stage outcomes plus sandbox_check callouts; `out/apply_preflight.json` shows `apply_ok: true`.
- Clean-channel runs now emit `out/run_manifest.json` with run_id + baseline host metadata; runtime mapping generators refuse to promote decision-stage artifacts unless `channel=launchd_clean`.
- Added unsandboxed baseline controls (`out/baseline_results.json`), a normalization control probe (`allow-subpath-normalized`), a flow-divert partial-triple profile (`flow_divert_partial_tcp`), and mismatch packets (`out/mismatch_packets.jsonl`) with enumerated mismatch reasons.
- Emitted `out/promotion_packet.json` via `python -m book.api.runtime emit-promotion` for plan-based consumers (field2-atlas/runtime mapping generators).
- Plan/registry files are now generated from the runtime template: `python -m book.api.runtime plan-build --template runtime-adversarial --out book/experiments/runtime-adversarial --overwrite` (plan-build skips expected_matrix.json by default; use `--write-expected-matrix` for a static snapshot).
- Re-ran via `python -m book.api.runtime run --plan book/experiments/runtime-adversarial/plan.json --channel launchd_clean` after wiring loopback fixture markers and canonicalization-boundary mismatch packets; latest bundle is `out/d3b1bbf8-fe92-43eb-9422-2dd4e122f77c/` with `fixtures.json`, `path_witnesses.json`, and `canonicalization_boundary` mismatch_reason for path_edges.
- Added xattr discriminators (allow-default with explicit xattr denies) and refreshed the clean-channel run; latest bundle is `out/7fb35590-c5c0-4187-8949-f534fbd43045/` and the xattr allow probe now reaches operation stage for field2=2.
- Added file-mode discriminator profile (`adv:file_mode`) using `/private/tmp/mode_allow` (0644) vs `/private/tmp/mode_deny` (0600) and refreshed the clean-channel run; latest bundle is `out/ec3df76c-6559-421b-8203-c32709667ffc/`.
- Added a mount-relative-path micro-suite (`adv:mount_relative_path`) with a subpath allow vs outside deny over `/private/tmp/runtime-adv/mountrel`, intended to give field2=1 a dedicated operation-stage discriminator without `/tmp` alias confounding.
- Attempted a launchd_clean run with the new mount-relative-path suite; launchctl bootstrap failed with rc=5 (Input/output error). Diagnostics are in `book/experiments/runtime-adversarial/out/c3a523bc-c462-4528-8ae8-0ed33ee16f79/launchctl/launchctl_diagnostics.json`, and log show was blocked (`Cannot run while sandboxed`).
- Launchd clean-channel run succeeded after staging fixes (avoid Desktop venv/TCC and skip staging `out/`), producing run_id `738fc3d0-1d12-4608-9a97-90addfbc8d4c`; the mount-relative-path allow/deny probes now reach operation stage and the promotion packet points to the new bundle.
