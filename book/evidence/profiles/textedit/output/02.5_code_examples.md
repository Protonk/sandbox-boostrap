### 2.5 TextEdit’s sandbox, by example

The earlier sections described TextEdit’s sandbox in prose. This section is the code counterpart: small, runnable examples that inspect the profile, entitlements, and container; trace concrete operations; and extract reusable patterns.

Each subsection below is designed to be anchored by one or more code examples in `profiles/textedit/`. The prose here is intentionally thin; later passes will expand it once the code is in place.

---

#### 2.5.1 Surveying what TextEdit can do

This subsection turns TextEdit’s entitlements and specialized profile into a concise capability summary.

**Example 1: Running the capability survey**

* Invoke the survey tool from the repo root, using the script under `profiles/textedit/tools/02.1_capability_survey.py`.
* Show the shape of the JSON it produces in `profiles/textedit/output/02.1_capability_summary.json`.

Placeholders:

```sh
$ python3 profiles/textedit/tools/02.1_capability_survey.py
```

```python
def load_entitlements(path: Path) -> Dict[str, Any]:
    with path.open("rb") as fh:
        return plistlib.load(fh)


def summarize_entitlements(entitlements: dict) -> dict:
    ubiquity_containers = entitlements.get(
        "com.apple.developer.ubiquity-container-identifiers", []
    )
    private_entitlements = [
        key
        for key in entitlements.keys()
        if key
        not in {
            "com.apple.security.app-sandbox",
            "com.apple.security.print",
            "com.apple.security.files.user-selected.read-write",
            "com.apple.security.files.user-selected.executable",
            "com.apple.developer.ubiquity-container-identifiers",
            "com.apple.application-identifier",
        }
    ]
    return {
        "sandbox_enabled": bool(entitlements.get("com.apple.security.app-sandbox")),
        "printing": bool(entitlements.get("com.apple.security.print")),
        "user_selected_files": {
            "read_write": bool(
                entitlements.get("com.apple.security.files.user-selected.read-write")
            ),
            "executable": bool(
                entitlements.get("com.apple.security.files.user-selected.executable")
            ),
        },
        "ubiquity": {"enabled": bool(ubiquity_containers), "containers": ubiquity_containers},
        "private_entitlements": sorted(private_entitlements),
    }
```

```json
{
  "entitlements": {
    "sandbox_enabled": true,
    "printing": true,
    "user_selected_files": {
      "read_write": true,
      "executable": true
    },
    "ubiquity": {
      "enabled": true,
      "containers": [
        "com.apple.TextEdit"
      ]
    }
  }
}
```

**Example 2: Turning JSON into a human checklist**

* Add a helper that converts the JSON summary into a short checklist of capabilities (e.g. “sandbox enabled”, “can print”, “has iCloud container”).

Placeholders:

```python
def load_capability_summary(path: Path) -> dict:
    with path.open("r", encoding="utf-8") as fh:
        return json.load(fh)


def print_checklist(summary: dict) -> None:
    ent = summary.get("entitlements", {})
    print("- sandbox enabled:", ent.get("sandbox_enabled"))
    print("- printing entitlement:", ent.get("printing"))
    user_files = ent.get("user_selected_files", {})
    print("- user-selected files: read_write=", user_files.get("read_write"), "executable=", user_files.get("executable"))
    ubiquity = ent.get("ubiquity", {})
    print("- ubiquity/iCloud enabled:", ubiquity.get("enabled"), "containers:", ubiquity.get("containers"))
    private = ent.get("private_entitlements", [])
    print("- private entitlements:", ", ".join(private) if private else "(none)")
```

```sh
$ python3 profiles/textedit/tools/02.1_capability_checklist.py
- sandbox enabled: True
- printing entitlement: True
- user-selected files: read_write= True executable= True
- ubiquity/iCloud enabled: True containers: ['com.apple.TextEdit']
- private entitlements: com.apple.private.hid.client.event-dispatch.internal
```

---

#### 2.5.2 Joining profiles, containers, and entitlements

Here we connect the static ingredients—profile, container, entitlements—using code that builds an explicit joined view.

**Example 3: Loading and joining profile, entitlements, and container**

* Use `profiles/textedit/tools/02.2_profiles_and_containers.py` to load:

  * `textedit-entitlements.plist`
  * `textedit-specialized.sb`
  * `container-notes.md`
* Show how it builds a joined structure (bundle id, container root, key booleans about profile structure).

Placeholders:

```python
def parse_container_notes(path: Path) -> Dict[str, object]:
    container_root = None
    known_subdirs = []
    if not path.exists():
        return {"container_root": container_root, "known_subdirs": known_subdirs}
    for raw_line in path.read_text(encoding="utf-8").splitlines():
        line = raw_line.strip()
        if not line:
            continue
        if line.startswith("container_root"):
            _, _, value = line.partition("=")
            container_root = value.strip()
        elif line.startswith(("-", "*")):
            known_subdirs.append(line.lstrip("-* ").strip())
    return {"container_root": container_root, "known_subdirs": known_subdirs}


def summarize_profile_structure(sb_text: str) -> Dict[str, bool]:
    return {
        "has_appsandbox_container_macros": "appsandbox-container" in sb_text,
        "has_dyld_path_rules": "application_dyld_paths" in sb_text,
        "has_bundle_param_rules": "application_bundle" in sb_text or "application_bundle_id" in sb_text,
        "has_application_container_rules": "application_container" in sb_text or "application_container_id" in sb_text,
    }
```

```json
{
  "bundle_id": "com.apple.TextEdit",
  "container_root": "~/Library/Containers/com.apple.TextEdit/Data",
  "has_app_sandbox": true,
  "profile": {
    "has_appsandbox_container_macros": true,
    "has_application_container_rules": true
  }
}
```

**Example 4: Printing a concise “shape” of TextEdit’s sandbox**

* Add a short wrapper that prints a one-line or one-screen description of TextEdit’s sandbox shape, derived from the join.

Placeholders:

```python
def format_human_shape(joined: dict) -> str:
    container = joined.get("container_root")
    profile_flags = joined.get("profile", {})
    flags = [
        f"container_macros={profile_flags.get('has_appsandbox_container_macros')}",
        f"dyld_rules={profile_flags.get('has_dyld_path_rules')}",
        f"bundle_params={profile_flags.get('has_bundle_param_rules')}",
    ]
    ent = joined.get("entitlements", {})
    caps = [
        f"printing={ent.get('printing')}",
        f"user_selected_rw={ent.get('user_selected_files', {}).get('read_write')}",
        f"ubiquity={bool(ent.get('ubiquity_containers'))}",
    ]
    return (
        f\"{joined.get('bundle_id')} -> container={container} | flags[{', '.join(flags)}] | caps[{', '.join(caps)}]\"
    )
```

```sh
$ python3 profiles/textedit/tools/02.2_profiles_and_containers.py
{
  "bundle_id": "com.apple.TextEdit",
  "container_root": "~/Library/Containers/com.apple.TextEdit/Data",
  "has_app_sandbox": true,
  "container_subdirs_count": 0,
  "profile_flags": {
    "has_appsandbox_container_macros": true,
    "has_dyld_path_rules": true,
    "has_bundle_param_rules": true,
    "has_application_container_rules": true
  }
}

Shape: com.apple.TextEdit -> container=~/Library/Containers/com.apple.TextEdit/Data | flags[container_macros=True, dyld_rules=True, bundle_params=True] | caps[printing=True, user_selected_rw=True, ubiquity=True]
```

---

#### 2.5.3 Tracing a single operation end-to-end

This subsection introduces traces: focused recordings of what happens when TextEdit performs a specific action.

**Example 5: “Open an existing document” scenario**

* Use `profiles/textedit/tools/02.3_trace_operations.sh` to define or run a scenario for opening a file in `~/Documents`.
* Show the intended trace artefact path under `profiles/textedit/traces/` and the kind of tool used (e.g. `fs_usage`).

Placeholders:

```sh
# From profiles/textedit/tools/02.3_trace_operations.sh
# Actions -> interesting traces:
# - Open file in ~/Documents: file opens in user paths; mach-lookup to tccd expected.
# - Auto-save to container: writes under container Data/Documents; temp files.
# - Print document: printing service interactions; possible sandbox extensions.
```

```sh
$ ls -1 profiles/textedit/traces
open-existing-document_fs_usage.log
# Synthetic fs_usage-style trace illustrating an open from ~/Documents and autosave into the container.
```

**Example 6: Mapping trace events back to SBPL rules**

* Add a small analysis helper that:

  * Reads a trace file (real or mock) for the scenario.
  * Filters for accesses outside the container (e.g. `~/Documents`).
  * Annotates those events with the SBPL concept that permits them (user-selected file entitlements + extension rules).

Placeholders:

```python
def annotate_line(line: str) -> str:
    lower = line.lower()
    if "/documents/" in lower and "containers/com.apple.textedit" not in lower:
        reason = "# user-selected file entitlement + sandbox extension"
    elif "containers/com.apple.textedit" in lower:
        reason = "# inside app container (appsandbox-container rules)"
    else:
        reason = "# ancillary access"
    return f"{line.rstrip()}    {reason}"


def annotate_trace(path: Path) -> None:
    for raw in path.read_text(encoding="utf-8").splitlines():
        if raw.strip().startswith("#") or not raw.strip():
            continue
        print(annotate_line(raw))
```

```text
# Synthetic trace annotated via 02.3_trace_annotate.py
14:32:10.123  TextEdit  open    /Users/demo/Documents/example.txt    # user-selected file entitlement + sandbox extension
14:32:10.125  TextEdit  getattr /Users/demo/Documents/example.txt    # user-selected file entitlement + sandbox extension
14:32:10.200  TextEdit  read    /Users/demo/Documents/example.txt    # user-selected file entitlement + sandbox extension
14:32:10.600  TextEdit  open    /Users/demo/Library/Containers/com.apple.TextEdit/Data/Library/Autosave Information/Unsaved Document 1.rtf    # inside app container (appsandbox-container rules)
14:32:10.900  TextEdit  write   /Users/demo/Library/Containers/com.apple.TextEdit/Data/Library/Autosave Information/Unsaved Document 1.rtf    # inside app container (appsandbox-container rules)
```

---

#### 2.5.4 Extracting patterns from TextEdit’s profile

This subsection uses code to distill the specialized profile into patterns that are likely shared across apps.

**Example 7: Mining common patterns**

* Use `profiles/textedit/tools/02.4_pattern_extraction.py` to identify:

  * Container vs system filesystem rules.
  * Mach-lookup patterns.
  * Network-related allows/denies.

Placeholders:

```python
def extract_common_patterns(sb_text: str) -> Dict[str, object]:
    mach_services = re.findall(r'global-name\\s+"([^"]+)"', sb_text)
    local_mach_services = re.findall(r'local-name\\s+"([^"]+)"', sb_text)
    all_mach_services: List[str] = mach_services + local_mach_services

    return {
        "filesystem_patterns": {
            "has_container_macros": "appsandbox-container" in sb_text or "application_container" in sb_text,
            "has_system_read_only": "/System" in sb_text or "/usr/bin" in sb_text,
            "has_home_library_allows": "/Library/" in sb_text,
        },
        "ipc_patterns": {
            "mach_lookups_total": len(re.findall(r"\\bmach-lookup\\b", sb_text)),
            "mach_services_examples": sorted(set(all_mach_services))[:10],
        },
        "network_patterns": {
            "has_network_star": "network*" in sb_text or "network-outbound" in sb_text,
            "has_specific_denies": "usbmuxd" in sb_text or "localhost:631" in sb_text,
        },
    }
```

```json
{
  "filesystem_patterns": {
    "has_container_macros": true,
    "has_system_read_only": true,
    "has_home_library_allows": true
  },
  "ipc_patterns": {
    "mach_lookups_total": 14,
    "mach_services_examples": [
      "PurplePPTServer",
      "PurpleSystemEventPort",
      "com.apple.AuthenticationServicesCore.AuthenticationServicesAgent",
      "com.apple.CARenderServer",
      "com.apple.CFPasteboardClient"
    ]
  }
}
```

**Example 8: Listing “interesting” or surprising rules**

* Use the same tool (or a helper) to collect narrow or special-case rules into buckets (“carve-out denies”, “keychain rules”, “App Store content rules”).

Placeholders:

```python
def identify_surprising_or_narrow_rules(sb_text: str) -> Dict[str, object]:
    lines = sb_text.splitlines()
    carve_out_denies = [ln for ln in lines if "(deny" in ln and ("subpath" in ln or "regex" in ln)]
    keychain_rules = [ln for ln in lines if "/Library/Keychains" in ln]
    mds_rules = [ln for ln in lines if "/private/var/db/mds" in ln]
    appstore_rules = [ln for ln in lines if "/Library/Application Support/AppStore" in ln]

    return {
        "carve_out_denies": carve_out_denies[:10],
        "keychain_rules": keychain_rules[:10],
        "mds_rules": mds_rules[:10],
        "appstore_rules": appstore_rules[:10],
    }
```

```text
appstore_rules:
  (subpath "/Library/Application Support/AppStoreContent")        # focused allow within broader /Library read rules
  (subpath "/Library/Application Support/AppStore")               # app store content reachable for receipts/support files
  "/Library/Application Support/AppStore/Content/"                # bundle-specific support paths

keychain_rules:
  (home-prefix "/Library/Keychains/")                             # standard per-user keychain access
  (home-subpath "/Library/Keychains/${ANY_UUID}")                 # explicit deny for UUID-named keychain directory

mds_rules:
  (subpath "/private/var/db/mds")                                 # metadata server database read for spotlight
```
