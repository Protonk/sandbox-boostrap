# Report – graph-shape-vs-semantics

## Purpose

This suite asks: when we deliberately construct SBPL/graph variants that are intended to have the same allow/deny semantics but different shapes, does this Sonoma world treat them equivalently at runtime? The aim is to learn which structural details (nesting, filter order, tag assignments, sharing) matter for semantics and which are just IR choices.

Right now the suite reuses the `runtime-adversarial` families for:
- filesystem structural variants (`adv:struct_flat`, `adv:struct_nested`, `adv:path_edges`) that now carry both file-read* and file-write* rules, and
- mach variants (`adv:mach_simple_allow`, `adv:mach_simple_variants`, `adv:mach_local_literal`, `adv:mach_local_regex`),
and summarizes “same behavior vs mismatch” across these pairs.

## Baseline & scope

- World: `sonoma-14.4.1-23E224-arm64-dyld-a3a840f9`.
- Harness: `python -m book.api.runtime run --plan book/evidence/experiments/runtime-final-final/suites/runtime-adversarial/plan.json --channel launchd_clean` (commit bundle + promotion packet; consumers use the packet export surface).
- Profiles:
  - `adv:struct_flat` and `adv:struct_nested`: same intended allow/deny surface over `/tmp/runtime-adv/struct/...`, different graph structures.
  - `adv:path_edges`: path/literal edge cases around `/tmp` vs `/private/tmp`.
  - `adv:mach_simple_allow` and `adv:mach_simple_variants`: mach global-name literal vs regex/nested forms.
  - `adv:mach_local_literal` and `adv:mach_local_regex`: mach local-name literal vs regex encodings.
- Inputs: promotion packet exports for `runtime_results` and `run_manifest` (no `out/` scraping).
- Outputs (this suite): derived summary + verdicts + counterexamples under `book/evidence/experiments/runtime-final-final/suites/graph-shape-vs-semantics/out/derived/<run_id>/` with a stamped consumption receipt, generated by `summarize_struct_variants.py`.

Scope today: the structural and mach families already defined in `runtime-adversarial`; no new profiles are introduced here yet.

## Mechanism

1. **Run adversarial probes**
   - Command: `python -m book.api.runtime run --plan book/evidence/experiments/runtime-final-final/suites/runtime-adversarial/plan.json --channel launchd_clean`.
   - Emit a promotion packet for the committed bundle.

2. **Compare variants (packet-only)**
   - Command: `python book/evidence/experiments/runtime-final-final/suites/graph-shape-vs-semantics/summarize_struct_variants.py --packet <promotion_packet.json>`.
   - This script:
     - Picks fixed profile pairs that are intended to be semantically equivalent:
       - struct_flat vs struct_nested,
       - mach_simple_allow vs mach_simple_variants,
       - mach_local_literal vs mach_local_regex.
     - Normalizes expectation IDs across variants (strips the profile prefix) to find probes that correspond to the same intent (e.g., “allow-ok-root” in both profiles).
     - For each shared expectation, records:
       - expected verdict,
       - actual verdict under each profile,
       - whether both profiles matched expectations.
     - Records mismatches (per pair) and also surfaces the `adv:path_edges` mismatches explicitly.
   - Output: `out/derived/<run_id>/graph_shape_semantics_summary.json`, `graph_shape_semantics_verdicts.json`, and `graph_shape_semantics_counterexamples.json` with provenance stamps.

The suite is intentionally thin: it reads existing runtime results and asks, “did the variants behave the same where they were designed to?”

## Current results

From the latest run described in `Notes.md`:

- **Structural variants: `adv:struct_flat` vs `adv:struct_nested` (reads and writes)**
  - Shared expectations include both read probes (`allow-ok-root`, `allow-ok-deep`, `deny-blocked`, `deny-outside`) and write probes (`write-ok-root`, `write-ok-deep`, `write-blocked`, `write-outside`).
  - For each shared expectation:
    - both profiles report the same `expected` and `actual` verdict,
    - both have `match: true`.
  - Summary: “different graph, same behavior” holds for both file-read* and file-write* across these filesystem profiles.

- **Mach global-name variants: `adv:mach_simple_allow` vs `adv:mach_simple_variants`**
  - Shared expectations: `allow-cfprefsd`, `deny-bogus`.
  - Both profiles allow the real service and deny the bogus one; all matches succeed.

- **Mach local-name variants: `adv:mach_local_literal` vs `adv:mach_local_regex`**
  - Shared expectations: `allow-cfprefsd-local`, `deny-bogus-local`.
  - Again, both profiles align on allow/deny behavior with full matches.

- **Path edges: `adv:path_edges`**
  - The `/tmp` expectations still deny at runtime, but they are now classified as canonicalization-boundary mismatches backed by `path_witnesses.json`.
  - Verdict logic treats these as canonicalization-aware equivalence: the path_edges transformation is preserved once you compare on witness-backed canonical spellings rather than raw `/tmp` strings.

These findings are summarized in `out/graph_shape_semantics_summary.json`.

## What system info and code we are using

- **System behavior**
  - The kernel’s sandbox decisions for file reads and mach lookups under structurally different but semantically equivalent profiles.
  - The behavior of `/tmp` vs `/private/tmp` at the VFS layer, which shows up as denies in the path_edges family.

- **Code paths**
  - `runtime-adversarial` defines the SBPL variants, expectations, and probe matrix; the harness runs them under consistent conditions.
  - `summarize_struct_variants.py` is a small comparison tool: it aligns probes between pairs and marks where behavior diverges or stays the same.

No decoder or tag-layout code runs directly in this suite, but the variants themselves were designed with the existing IR/tag understanding in mind.

## What else this suite could tell us

With additional variants and small changes, this suite could:

- **Probe more structural features**
  - Introduce variants that differ only in metafilter structure, decision modifiers, or tag assignments within the modeled tag set, while holding intent fixed. Comparing their runtime behavior would test whether our current reconstruction treats those differences as semantically irrelevant (as intended) or not.

- **Stress tag/layout assumptions**
  - Construct pairs where we deliberately change which tag encodes a particular literal or filter combination, staying within the set of tags we consider canonical. If behavior changes unexpectedly, that would suggest our tag/layout interpretations are incomplete.

- **Explore other ops**
  - Create structural variants for non-filesystem, non-mach operations (network, IPC, extensions) to see whether “different graph, same behavior” holds there as well.

## How we could vary or strengthen the experiments

- **Richer alignment**
  - Today we align variants by normalized expectation IDs. We could extend the comparison to include decoded graph features (node tag sets, edge patterns) per expectation, making it explicit which structural differences are being “ignored” by the kernel.

- **New profile families**
  - Design new SBPL families that are intentionally tricky:
    - deeply nested vs flattened,
    - shared subgraphs vs duplicated filters,
    - different combinations of `allow`/`deny` and `require-any`/`require-all` structures.
  - Then re-run this suite to see which patterns are semantically equivalent and which are not.

- **Environment and path variants**
  - For path_edges and similar families, adding probes that vary the working directory, symlink use, or chroot-like setups could help isolate exactly how far VFS behavior diverges from profile intent and where that sits relative to the PolicyGraph model.

## Summary

An agent reading this file and `Notes.md` should come away with:
- An understanding that this suite is about “graph shape vs behavior” for carefully chosen profile pairs.
- The observation that, for the existing filesystem and mach variants, different shapes do in fact lead to the same allow/deny outcomes on this host.
- The caveat that path_edges remains bounded by the `/tmp`→`/private/tmp` canonicalization boundary, which is now treated as an equivalence class rather than a shape/semantics counterexample.
- A set of concrete ideas for new variants and alignment checks that would deepen our understanding of which structural details matter for semantics in this world.***
