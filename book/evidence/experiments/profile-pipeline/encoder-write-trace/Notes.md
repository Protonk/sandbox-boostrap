# Notes

- Initialized experiment scaffold and harness layout.
- Built the interposer dylib via `harness/build_interposer.sh`.
- Interposer load failed: `dyld` aborts with `symbol not found in flat namespace '__sb_mutable_buffer_write'` when injecting into the compile process.
- Verified baseline compilation without interposer: `out/blobs/_debug.sb.bin` from `baseline/allow_all.sb`.
- Updated the interposer to record triage metadata and support dynamic/patch hook modes; `run_trace.py` now writes per-input triage output and accepts mode/address overrides.
- `nm -m` on the extracted libsandbox image (`book/evidence/graph/mappings/dyld-libs/usr/lib/libsandbox.1.dylib`) shows `_sb_mutable_buffer_write` as non-external; `otool -Iv` shows no indirect-symbol entry for it.
- `xcrun dyld_info -exports /usr/lib/libsandbox.1.dylib` and `-imports` do not list `_sb_mutable_buffer_write` (no matches).
- `xcrun dyld_info -exports book/evidence/graph/mappings/dyld-libs/usr/lib/libsandbox.1.dylib` reports segment load commands out of order, so dyld_info evidence uses the `/usr/lib` image as a fallback.
- Patch mode now accepts an unslid VM address and computes the runtime target using the dyld slide for the loaded libsandbox image.
- Ran `run_trace.py --mode patch --only-id baseline_allow_all`; patch attempt failed with `mprotect failed: Permission denied` and produced no write records.
- Ran `run_trace.py --mode patch --only-id baseline_allow_all --dyld-shared-region private`; patch still failed with `mprotect failed: Permission denied` despite a zero slide.
- Ran `run_trace.py --mode patch --only-id baseline_allow_all --dyld-shared-region avoid`; compile process aborted because `/usr/lib/libSystem.B.dylib` is not on disk when the shared cache is avoided.
- Adjusted the reachability gate so `mprotect failed` no longer raises; patch-mode run now completes and records `hook_failed` with `mprotect failed: Permission denied`.
- Added a `mach_vm_protect(..., VM_PROT_COPY)` fallback for text patching; patch runs now record `vm_protect_copy failed: (os/kern) protection failure` when both protection paths are blocked.
- Ran `run_trace.py --mode patch --only-id baseline_allow_all` and `--dyld-shared-region private`; both runs still failed with `mprotect failed: Permission denied; vm_protect_copy failed: (os/kern) protection failure` and produced no write records.
- Switched the patcher to a W^X-correct flow (RW then RX, no RWX) and added Mach VM region metadata via `mach_vm_region_recurse`; triage now records protection and max-protection flags.
- Patch-mode runs now show the target region as `r-x` with `max_protection` also `r-x` (`max_has_write: false`), which is consistent with an immutable `__TEXT` mapping on this host.
- Patch-mode runs now skip patching when `max_has_write: false`, recording `hook_status: skipped_immutable` and `hook_error: region_max_protection_no_write` in triage.
- Attempted a non-shared-cache helper by setting `SBPL_SANDBOX_PATH=book/evidence/graph/mappings/dyld-libs/usr/lib/libsandbox.1.dylib`; `ctypes.CDLL` failed with a code-signature error ("Trying to load an unsigned library").
- Extracted a fresh libsandbox with `extract_dsc.swift` into a temporary directory and copied it to `book/evidence/experiments/profile-pipeline/encoder-write-trace/out/libsandbox/libsandbox.1.dylib`; `codesign --sign -` failed with `main executable failed strict validation` (same with `--options=linker-signed`).
- Attempted DTrace pid-provider tracing (`dtrace -n pid$target:libsandbox.1.dylib::_sb_mutable_buffer_write:entry ...`); SIP blocked it with "DTrace requires additional privileges".
- Added a hardware-breakpoint hook (Mach exception port + ARM_DEBUG_STATE64) and a new `hw_breakpoint` mode.
- Generated `harness/mach_exc_server.c` and `harness/mach_exc_server.h` via `mig` from `mach_exc.defs` to back the exception server.
- Ran `run_trace.py --mode hw_breakpoint --only-id baseline_allow_all --allow-zero-hits`; hook armed successfully and recorded 271 write records in `out/traces/baseline_allow_all.jsonl` with `hook_status: ok` in triage.
- Hardened `hw_breakpoint` handling with exception forwarding, a ring-buffer write queue, and a background flush thread to keep the exception handler minimal (no stdio/malloc/locks in the hot path).
- Added `mach_exc_user.c`/`.h` and updated `harness/build_interposer.sh` to link the forwarding stubs.
- A strict PC == target filter caused `SIGTRAP` aborts during `baseline_allow_all` compilation; adjusted the PC comparison to tolerate the next-instruction address (`target+4`) for AArch64 debug exceptions.
- Ran `run_trace.py --mode hw_breakpoint --only-id baseline_allow_all` after the PC adjustment; trace emitted 226 records and completed without abort.
- Ran `analyze_trace.py` and `check_trace_join.py`; outputs written to `out/trace_analysis.json` and `out/trace_join_check.json` (join check skipped network pairs because only `baseline_allow_all` is present in the trace manifest).
- Updated the hardware-breakpoint handler to classify break vs step using Mach exception codes (EXC_BREAKPOINT + EXC_ARM_BREAKPOINT, subcode gating) instead of PC tolerance; reran `baseline_allow_all` without SIGTRAP.
- Extended `analyze_trace.py` to align gapped coverage to a blob window and emit `witnessed_ranges` vs `hole_ranges`; `check_trace_join.py` now labels offsets as witnessed vs inferred when coverage is gapped (still skips network pairs without trace coverage).
- Switched to task-level exception routing (`task_swap_exception_ports`) and added proactive per-thread breakpoint arming via `task_threads` plus a periodic monitor thread.
- Added per-thread step state tracking and explicit counters for ring drops, truncated captures, forwarded exceptions, arm failures, and rescan counts in triage.
- Trace JSONL records now include `reported_len` and `chunk_offset` for hardware-breakpoint chunks to make partial captures visible.
- After switching to task-level exception routing with code/subcode gating, `baseline_allow_all` failed with `SIGSEGV` and then `SIGTRAP`; the handler was not reliably classifying breakpoint events on this host.
- Relaxed breakpoint classification to treat `EXC_BREAKPOINT` events as break/step based on per-thread `step_active` (no code/subcode gating) to avoid unhandled `SIGTRAP` while keeping forward-only for non-breakpoint exceptions.
- Added a stats sidecar (`out/stats/*.stats.json`) and merged it into triage under `hw_breakpoint_stats`.
- Re-ran `baseline_allow_all`: stats show `ring_dropped: 0`, `capture_truncated: 0`, `break_hits: 249`, `step_hits: 249`, suggesting the 6‑byte hole is not a capture truncation on this host.
- Ran the domain pair (`domain_af_inet`, `domain_af_system`) using `inputs_domain_pair.json` and re-ran `analyze_trace.py` + `check_trace_join.py`; one network diff was checked and both sides reported missing coverage at offset 410.
- Extended `inputs_domain_pair.json` with the type pair (`type_sock_stream`, `type_sock_dgram`) and re-ran `run_trace.py` + `analyze_trace.py` + `check_trace_join.py`; two network diffs were checked and both pairs still missed offset 410 (outside the traced 21‑byte window).
- Updated `check_trace_join.py` to prefer gapped alignment windows when they provide wider coverage than the best subset match; reran the join check and both domain/type pairs now report witnessed coverage at offset 410.
- Expanded the input set with the proto pair (`proto_tcp`, `proto_udp`) and re-ran `run_trace.py` (using `--allow-zero-hits` after a one-off SIGSEGV), then re-ran `analyze_trace.py` and `check_trace_join.py`; three network pairs now report witnessed coverage at offset 410.
- `run_trace.py` now retries the compile subprocess on SIGSEGV/SIGTRAP by default and records attempts/signals in the per-input `compile` record instead of aborting the run.
- The manifest now records a lightweight `trace_integrity` summary per input (trace/stats/triage present, compile status) without gating analysis on it.
- Added a compile-string path and compile params handling in `compile_one.py` / `run_trace.py`, then ran `run_trace.py --inputs book/evidence/experiments/profile-pipeline/encoder-write-trace/inputs_params.json --mode triage`.
- Results: compiling `param_path.sb` without params fails for both file and string modes with `compile failed: invalid data type of path filter; expected pattern, got boolean`, while compiling with `{"ROOT": "/private/tmp"}` succeeds in both modes.
- Ran `run_trace.py --inputs book/evidence/experiments/profile-pipeline/encoder-write-trace/inputs_params.json --mode hw_breakpoint` and re-ran `analyze_trace.py`. The no-params runs still emitted write records before the compile error (file: 109 records; string: 18 records). With params, file and string runs succeeded and emitted similar write counts (file: 218 records; string: 212 records), both with the same 6‑byte hole (`[394,400)`).
- Expanded `inputs_params.json` with additional compile-flavor examples (file vs string for baseline and a network-matrix pair, unused params, alternate param value, a gate-witness specimen, and a golden-triple specimen).
- Ran `run_trace.py --inputs book/evidence/experiments/profile-pipeline/encoder-write-trace/inputs_params.json --mode hw_breakpoint` and re-ran `analyze_trace.py` for the expanded set. Baseline allow_all file vs string matched trace counts (214 each) and window `[0,416)` with a `[394,400)` hole. Adding an unused param kept the window but reduced records (193).
- Param-path runs: both file and string fail without params (same error), emitting 16 records before failure. With params, file vs string counts are close (204 vs 206) and share the `[394,400)` hole; using the alternate param value increases the window length to 511 with the same hole.
- Network-matrix pair dt_all_inet_stream: file vs string both succeed with small reconstructed length (21) and no gapped alignment; trace counts differ (234 vs 224).
- Gate-witness airlock minimal: file vs string succeed with window length 513 and a `[396,400)` hole; trace counts differ slightly (222 vs 216).
- Golden-triple strict_1: file mode succeeds with reconstructed length 22 and no gapped alignment.
- Added a secondary hardware-breakpoint target for `_sb_mutable_buffer_make_immutable`; stats now include `immutable_hits` and `immutable_buf` (the immutable buffer pointer does not align with write-event buffer addresses in current traces).
