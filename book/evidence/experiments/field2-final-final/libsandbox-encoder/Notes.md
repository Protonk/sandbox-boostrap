- Initialized experiment scaffolding; phases and deliverables captured in Plan.md.
- Pulled web-model heuristics for Phase B: anchor on the profile buffer allocator/serializer in `libsandbox` (buffer passed to `__mac_syscall`), find the node-emission loop and `strh` at the known `field2` offset, and backtrack through `_filter_info` consumers and TinyScheme primitive table xrefs (strings like `allow`, `deny`, `literal`, `regex`, `subpath`) to per-filter helpers that intern args (literal/regex/number) before serialization. Expect primitive tables and `_filter_info` to remain flat arrays (PAC stubs aside) inside `libsandbox`, with `libsystem_sandbox` as API glue only.
- Phase A sketch: target operations `file-read*`, `mach-lookup`, `network-outbound`; filter/arg shapes to probe include literal path, subpath, regex path (if the compiler accepts it), socket domain/type/proto triples, iokit class/property, mach names/anchors. Plan to record `(op, filter_name, SBPL arg text, filter_id from filters.json, tag, raw field2)` in `out/field2_encoder_matrix.json` and explicitly check for mismatches/high codes (16660, 2560, 0xffff, 3584, 10752).
- Implemented Phase A matrix v1 (regex-free) in `sb/matrix_v1.sb`: file-read* with literal/subpath, mach-lookup with global/local names, network-outbound with socket domain/type/proto, iokit-open with registry-entry-class/property. Regex probes deferred to a follow-up matrix to keep the baseline clean.
- Filter vocab references for planned probes (from `filters.json`): `path`=0, `global-name`=5, `local-name`=6, `socket-domain`=10, `socket-type`=11, `socket-protocol`=12, `iokit-registry-entry-class`=16, `iokit-property`=17.
- Added `run_phase_a.py` helper (profile_ingestion + decoder) to compile `matrix_v1`, slice nodes, and emit `out/field2_encoder_matrix.json`. Updated to load local tag-layout overrides and skip tags without payloads; literal_refs still attached heuristically.
- Staged local tag-layout overrides in `out/tag_layout_overrides.json` (priority over published mappings): tag3/tag8 payload at field[2]; tag2/tag10 provisional (record_size 12, payload field[2] for tag10, none for tag2).
- Phase A v1 observations (after overrides):
  - Header op_count=11; node_count=33 (tags {10,8,4,0,6,3}, remainder 3 bytes). Payload extraction now uses tag-specific layouts.
  - field2 values are all mapped to vocab IDs: socket-domain (10) dominates tag10 nodes; remote (8), control-name (9), local-name (6) appear on a few nodes with matching literal refs. No unknown/high codes surfaced in this pass.
  - Literal refs surface the injected strings (`/tmp/encoder/*`, mach names, iokit strings); nodes carrying literals now align with filter IDs instead of collapsing to socket-domain everywhere.
- Slicing sanity via inspect_profile: tiny profiles (`single_file_literal/subpath`, `single_network_domain`) have nodes_start/literal_start aligned (e.g., nodes_start=22, literal_start=369 for single_file_literal). Despite correct slicing, tag2/tag3 dominate those tiny profiles with constant field values, suggesting meta/scaffolding rather than filter nodes.
- Quick tag inventory check (existing `tag_inventory.json` + tiny blobs): tag2 and tag3 appear in many profiles with counts fixed per stride (often 1 per op or header-like) and fields stable; no evidence they vary with SBPL args. Leaning toward marking tag2/tag3 as meta (no payload) in local overrides and excluding them from the encoder matrix; tag10/8/6/9 remain the active filter-bearing tags.
- Updated local overrides to mark tag2/tag3 as meta/no payload, reran Phase A: `field2_encoder_matrix.json` now only includes tags with payloads (10/8/6/9). Next focus: differentiate filter-ID vs payload fields for tags 10/8/6/9 across existing profiles without adding new probes.
- Added `build_tag_field_summary.py` to summarize payload-bearing tags from the encoder matrix. Current summary (matrix v1):
  - tag10: field[2] is vocab ID {6,8,9,10}; other fields vary across rows (field0/1 ∈ {9,10}, field3/4 ∈ {0,8,10}). Per-filter buckets show all fields constant for a given filter/literal in this matrix, so payload location still ambiguous without more arg variance.
  - tag8: single row, all fields fixed at 10 (socket-domain) -> likely scaffolding/sibling in this profile.
  - tag0: single row with fields [2560,21,10,1,3328], literal_refs present; could encode arg/index in non-field2 slots; excluded from payload inference for now.
- Attempted `matrix_v2` (arg variance for socket-domain/control-name/local-name); decode currently skewed to tag6/tag5 only (no tag10 rows) due to op/layout issues. To avoid churn, freezing Phase A with v1 matrix; payload slot for tag10 remains ambiguous (field[3]/[4]) until Phase B disassembly clarifies serializer stores.

### Phase A v1 Status (frozen)

- Tag roles: tag2/tag3 are classified as meta/header (no payload) and are excluded from the encoder matrix. Payload-bearing tags in scope are currently {10,8,6,9}.
- Tag10 layout: field[2] is confirmed as the filter ID slot (values {6,8,9,10} matching the Filter Vocabulary Map). The payload slot for tag10 remains ambiguous between field[3] and field[4] based on matrix_v1; Phase A does not resolve this.
- Matrices: `matrix_v1_field2_encoder_matrix.json` provides a clean, vocab-aligned baseline; `matrix_v2` exists but its decode is skewed (tag6/5 only) and is not used for conclusions.
- Next step: Phase B will inspect libsandbox’s profile serializer to identify the per-tag10 store pattern, resolve the payload offset, and feed that back into tag_layout_overrides and future Phase A matrices.

### Phase B kick-off

- libsandbox slice: `book/evidence/graph/mappings/dyld-libs/usr/lib/libsandbox.1.dylib` (arm64e, ~512KB). `nm -gU` shows exported compile/apply symbols (`_sandbox_compile_*`, `_sandbox_apply`, `_sandbox_apply_container`) plus profile-related helpers (`___emit_profile_block_invoke`, `__populate_atom_tables_profile`, etc.).
- Need to identify the profile serializer path (buffer allocator → node emission loop) and map halfword stores for tag10. Initial `otool -p` lookup for `_populate_atom_tables_profile` failed (likely non-external symbol lookup); next steps: disassemble via address/symbol table or Ghidra to find the serializer and the `__mac_syscall` call site.

## Updated

- Updated: refreshed Phase A artifacts under the world-scoped stride=8 framing (tag layouts now record `record_size_bytes=8`). `run_phase_a.py` now emits `field2_raw/hi/lo` using 8-byte records and regenerates `out/matrix_v1_field2_encoder_matrix.json` and `out/matrix_v2_field2_encoder_matrix.json`.
- Updated: local `out/tag_layout_overrides.json` record sizes are now stride=8; historical stride=12 interpretations should be treated as superseded by the promoted stride=8 framing.
- Updated: rewrote `Report.md` to remove the historical stride=12 “closed” posture; Phase A matrices are treated as descriptive under stride=8, and any per-tag field semantics in `out/tag_layout_overrides.json` remain `partial`/experiment-local until independently witnessed and promoted.
- Updated: added the Phase A “network arg matrix” specimen set under `sb/network_matrix/` (manifest: `sb/network_matrix/MANIFEST.json`) plus runners `run_network_matrix.py` and `diff_network_matrix.py`, generating `out/network_matrix/{index.json,node_records.jsonl,blob_diffs.json}`.
- Updated: network arg diff witness (from `out/network_matrix/blob_diffs.json`): single-arg deltas show a single changed byte in the nodes region for the minimal specimens; observed macro expansions on this host baseline include AF_SYSTEM→`32`, SOCK_DGRAM→`2`, IPPROTO_UDP→`17` (paired against AF_INET `2`, SOCK_STREAM `1`, IPPROTO_TCP `6`).
- Updated: captured static RE excerpts for `_emit`, `_emit_network`, and `_record_condition_data` under `out/static_re/` (otool disassembly), and noted the Phase A join-point in `out/encoder_sites.json`.
- Updated: expanded `Report.md` with a new “byte-level structural join” branch (Phase A → Phase B) that treats compiled blobs as the oracle and lays out the plan to map `_emit_network`’s {1,1,2} writes to concrete blob structure using an extended SBPL matrix plus a diff-anchored join analyzer.
- Updated: expanded the Phase A network matrix specimen set (`sb/network_matrix/`) with pairwise combos, isolated triple variants, and a numeric proto witness (`proto_256.sb`); regenerated `out/network_matrix/{index.json,node_records.jsonl,blob_diffs.json}` with additional diff pairs to isolate arg deltas inside combined forms.
- Updated: added `join_network_matrix.py` and generated `out/network_matrix/{join_records.jsonl,join_summary.json}` to normalize diff offsets into stride-8 record context for both sides of each pair; key witness: `proto_tcp_vs_256` flips both bytes of the proto u16 in the minimal single-filter specimen, matching `_emit_network`’s 2-byte proto emission.
- Updated: revised `out/encoder_sites.json` to point `_emit_network` at the expanded Phase A join artifacts (`blob_diffs.json`, `join_records.jsonl`, `join_summary.json`) and to explicitly note the three witnessed structural roles across single-arg, pairwise-combined, and triple require-all forms.
- Updated: extended the Phase A network matrix with combined-form proto high-byte probes: pairwise (domain+proto, type+proto) `*_256` cases under `require-all` and `require-any`, plus triple `*_256` cases under `require-all`, `require-any`, and nested `require-all`.
- Updated: regenerated `out/network_matrix/*` and confirmed proto high-byte placement in combined forms: pairwise `pair_*_tcp_vs_*_256` diffs flip both bytes of the same u16[0] slot (within_record_offset 2/3), while triple `triple_*_tcp_vs_*_256` diffs flip the record header bytes (tag=lo at within_record_offset 0, kind=hi at within_record_offset 1), witnessing a 16-bit proto value spread across the first two bytes of the record.
- Updated: added an experiment-local SBPL↔blob oracle extractor `oracle_network_matrix.py` and generated `out/network_matrix/oracle_tuples.json`, which extracts (domain,type,proto) from the compiled blobs using only the Phase A structural witnesses.
- Updated: migrated the maintained network tuple oracle into `book/api/profile/oracles/` and marked `oracle_network_matrix.py` as historical; the experiment corpus and `out/network_matrix/oracle_tuples.json` remain as the parity baseline.
- Added order-variant require-all pair specimens (`pair_dt_all_inet_stream_order2`, `pair_dp_all_inet_tcp_order2`, `pair_tp_all_stream_tcp_order2`) plus diff pairs to check clause-order effects.
- Regenerated network matrix artifacts (`index.json`, `node_records.jsonl`, `blob_diffs.json`, `join_records.jsonl`, `join_summary.json`, `oracle_tuples.json`) after the manifest update.
- Added `analyze_network_join.py` to score join hypotheses and emit `out/network_matrix/join_hypotheses.json`; results are `status: ok` for the small-diff pairs.
- Added `check_network_join.py` as an experiment-local guardrail for the join hypotheses; current run passes on this matrix.
- Added encoder-write-trace subset inputs (`book/evidence/experiments/profile-pipeline/encoder-write-trace/inputs_network_matrix_subset.json`) mirroring network-matrix singles/pairs/triples plus baseline allow_all; ran `run_trace.py --mode hw_breakpoint`, `book/tools/sbpl/encoder_write_trace_analyze.py`, and `book/tools/sbpl/encoder_write_trace_check.py`.
- Generated trace-backed join artifacts: `out/network_matrix/encoder_write_join.json` (per-spec join window + holes) and `out/network_matrix/encoder_write_events.jsonl` (write_event → blob_offset spans).
- Cross-comparison: network-matrix specs align to gapped windows (len 484/492/500) with a `[394,400)` hole; baseline allow_all aligns to window 416 with the same hole. `trace_join_check.json` reports `pairs_checked: 35`, `missing: 40`, with missing offsets (484–491) concentrated in the “single vs combined” diff pairs (`domain_only_vs_pair_dp_all_inet_tcp`, `proto_only_vs_pair_dp_all_inet_tcp`, `type_only_vs_pair_tp_all_stream_tcp`, `proto_only_vs_pair_tp_all_stream_tcp`, `pair_dt_all_vs_triple_all_tcp`).
- Expanded the trace subset to include the full network-matrix manifest and re-ran the hw-breakpoint trace + join; `pairs_checked` increased to 35 but the same 40 missing offsets remain, all at the tail (`offsets 484–491`) of the single vs combined diffs.
- Added a secondary hardware-breakpoint target for `_sb_mutable_buffer_make_immutable` and reran; stats now record `immutable_hits` and `immutable_buf` but the immutable buffer pointer does not match the write-event buffer addresses, and the missing offsets remain unchanged.
- Added `encoder_write_record_map.py` to map traced write windows onto stride-8 record boundaries using `out/network_matrix/index.json`; output in `out/network_matrix/encoder_write_record_map.json` summarizes within-record offset coverage per spec.
